{"pages":[{"title":"About Me","text":"二次元不肥宅一名😅 目前就读于武汉某211 研究方向：FPGA/ASIC 本人比较喜欢硬件方面的东西，软件只有较浅的涉足 曾获湖北省电赛一等奖（因为国赛延期了）、集成电路创新设计大赛ARM杯全国一等奖第一名 在这里推荐一个大佬的FPGA入门路线：https://leiblog.wang/ 目前拟保研，研究生阶段期望方向为ASIC、数字IC设计 如果您发现文章中的内容有什么问题/有什么好的建议 欢迎联系我：hank.gan@foxmail.com 虽说本科阶段college有些槽点，但还是认真感谢带我竞赛的各位导师教授和学长🙏","link":"/about/index.html"}],"posts":[{"title":"Verilog HDL 简介与基本语法（1）","text":"FPGA学习 阶段一：Verilog HDL 简介与基本语法（1） ¶FPGA硬件开发路线学习规划： 由于想学习FPGA的相关内容，同时给数字电路打点基础，于是借助着B站上西安电子科技大学的视频开始学习Verilog HDL这门硬件描述语言，在学完语言后，将按照**《FPGA设计技巧与案例开发详解》**这本书上的相关内容在一块核心为Altera Cyclone IV的开发板上完成基本例程，之后在网上寻找相关项目学习、开发 ¶1. Verilog的基本概念 Verilog是一门类C语言，语法非常接近C，将电路设计转变为程序设计 Verilog的代码对应的是现实中的一个硬件，这个过程叫“综合”，类似于C语言的编译 Verilog的代码是并行执行的 ¶2. Verilog HDL基础知识 ¶2.1 Verilog HDL语言要素 ¶2.1.1 空白符 空白符包括空格符\\b、制表符\\t、换行符\\n、和换页符\\f。在编译和综合时，空白符被忽略： 123456789initial begin a = 3'b100; b = 3'b010; endequals to:initialbegin a = 3'b100; b = 3'b010;end ¶2.1.2 注释符 注释与C语言相同，单行注释用//，多行注释用/* */ ¶2.1.3 标识符 标识符命名规则与C语言基本相同，只允许出现字母、数字、$符号和_ 下划线，第一个字符必须是字母或 _下划线 ¶2.1.4 数值 Verilog HDL有四种基本的逻辑数值状态： 状态 含义 0 低电平、逻辑0、“假” 1 高电平、逻辑1、“真” x或X 不确定或未知的逻辑状态 z或Z 高阻态 备注：高阻态High impedance表示电路中的某个节点具有相对电路中其他点相对更高的阻抗 电路分析时高阻态可做开路理解。可以把它看作输出(输入)电阻非常大。它的极限状态可以认为悬空(开路)。 当门电路的输出上拉管导通而下拉管截止时,输出为高电平;反之就是低电平;如上拉管和下拉管都截止时,输出端就相当于浮空(没有电流流动),其电平随外部电平高低而定,即该门电路放弃对输出端电路的控制 。 整数及其表示 +/-(size&gt;'&lt;base_format&gt;&lt;number&gt; 数制 基数符号 合法标识符 二进制 b或B 0、1、x、X、z、Z、？、_ 八进制 o或O 0~7、x、X、z、Z、？、_ 十进制 d或D 0~9、_ 十六进制 h或H 09、af、A~F、x、X、z、Z、？、_ 1234567891011//正确的表示8'b10001101 //位宽为8位的二进制数100011018'ha6 //位宽为8位的十六进制数a65'o35 //位宽为5位的八进制数354'd6 //位宽为4位的十进制数64'b1x_01 //位宽为4位的二进制数1x01//错误的表示4'd-4 //数值不能为负，有负号应放在最左边3' b001 //'和基数b之间不能有空格(4+4)'b11 //位宽不能是表达式 实数及其表示 和C语言相同： a.十进制表示法，小数点两边必须都有数字 b.科学计数法 1234562.7 //十进制计数法5.2e8 //科学计数法3.5E-6 //e和E意义相同5_4582.2158_5896 //使用下划线可提高可读性6. //非法表示.3e5 //非法表示 ¶2.2 物理数据类型 物理数据类型有连线型、寄存器型和储存器型 ¶2.2.1 信号强度 信号强度表示数字电路中不同强度的驱动源，用来解决不同驱动强度存在下的赋值冲突： 标记符 名称 类型 强弱程度 supply 电源级驱动 驱动 最强 strong 强驱动 驱动 强 pull 上拉级驱动 驱动 较强 large 大容性 存储 中强 weak 弱驱动 驱动 中 medium 中性驱动 存储 较弱 small 小容性 存储 弱 highz 高容性 高阻 最弱 ¶2.2.2 连线型 连线型数据类型 功能说明 wire,tri 标准连线（缺省视为该类型） wor,trior 多重驱动时，具有线或特性的连线型 wand,trand 多重驱动时，具有线与特性的连线型 trireg 具有电荷保持特性的连线型数据（特例） tri1 上拉电阻 tri0 下拉电阻 supply1 电源线，用于对电源建模，为高电平1 supply0 电源线，用于对“地”建模，为低电平0 单连线之间的逻辑wire和tri wire/tri 0 1 x z 0 0 x x 0 1 x 1 x 1 x x x x x z 0 1 x z 含有线或时连线之间的逻辑 wor/trior 0 1 x z 0 0 1 x 0 1 1 1 1 1 x x 1 x x z 0 1 x z ¶2.2.3 连续型数据类型的声明 &lt;net_declar&gt;&lt;drive_strength&gt;&lt;range&gt;&lt;delay&gt;&lt;list_of_variables&gt;; net_declar：包括wire、tri等等连线型中的任意一种 dirve_strength:用来表示连线变量的驱动强度 rang：用来指定数据位标量或矢量。若该项默认，表示数据类型为1位的标量，超过1位则为矢量 delay：指定仿真延迟时间 list_of_variables：变量名称，一次可定义多个名称，用逗号分开 ¶2.2.4 寄存器型 reg型是数据储存单元的抽象类型，其对应的硬件电路原件具有状态保持作用，能够存储数据，如触发器、锁存器等 reg型变量常用于行为级描述，由过程赋值语句对其进行赋值 12345678//reg型变量简单例子：reg a; //定义一个1位的名为'a'的reg变量reg[3:0]b; //定义一个4位的名为'b'的reg变量reg[8:1]c,d,e; 定义三个名称分别为c、d、e的8位reg型变量//reg型变量一般为无符号数，若将一个负数赋给reg型变量，则自动转换成二进制补码形式。例如：reg signed[3:0]rega;rega = -2; //rega的值为1110(14)，是2的补码 ¶2.2.5 寄存器型数据类型的声明 reg&lt;range&gt;&lt;list_of_register_variables&gt;; range：可选项，它指定了reg型变量的位宽，缺省时为1位 list_of_register_variables：为变量名称列表，一次可以定义多个名称，之间用逗号分开 ¶2.2.6 物理数据类型声明的例子 123456789101112reg rega; //定义一个1位寄存器型变量reg[7:0] regb; //定义一个8位的寄存器型变量tri[7:0] tribus; //定义一个8位的三态总线tri0[15:0] busa; //定义一个16位连线型，处于三态时为下拉电阻tri1[31:0] busb; //定义一个32位连线型，处于三态时为上拉电阻reg scalared[1:4] b;//定义一个4位的标量型储存器矢量wire(pull1,strong0) c = a + b; //定义一个1和0的驱动强度不同的1位连线型变量ctrireg(large) storeline; //定义一个具有大强度的电荷存储功能的存储线/*在数字电路中，三态逻辑(英语:Three-state logic)允许输出端在0和1两种逻辑电平之外呈现高阻态，等效于将输出的影响从后级电路中移除。这允许多个电路共同使用同一个输出线，例如总线结构在总线连接的结构上。总线上挂有多个设备，设备与总线以高阻的形式连接。这样在设备不占用总线时自动释放总线，以方便其他设备获得总线的使用权.*/ ¶2.2.7 存储器型 储存器型变量可以描述RAM型、ROM型储存器以及reg文件 储存器变量的一般声明格式为： reg&lt;range1&gt;&lt;name_of_register&gt;&lt;range2&gt; range1和range2都是可选项，缺省都为1 range1：表示存储器当中寄存器的位宽，格式为[msb:lsb] range2：表示寄存器的个数，格式为[msb:lsb]，即拥有msb-lsb+1个 name_of_registers：变量名称，一次可以定义多个名称，之间用逗号隔开 12345reg[7:0] mem1[255:0]; //定义了一个有256个8位寄存器的存储器mem1 //地址范围是0到255reg[15:0] mem2[127:0],reg1,reg2;//定义了一个具有128个16位寄存器的储存器mem2和两个16位寄存器reg1和reg2reg[n-1:0] a; //表示一个n位寄存器areg mem1[n-1:0] //表示一个由n个1位寄存器构成的存储器mem1 ¶2.3 抽象数据类型 抽象数据类型主要包括整型integer、时间型time、实型real及参数型parameter ¶2.3.1 整型 integer&lt;list—of—register—variables&gt;; 12integer index; //简单的32位有符号整数integer i[31:0]; //定义了整型数组，它有32个元素 ¶2.3.2 时间型 时间型数据与整型数据相似，只是它是64位无符号数。时间型数据主要用于对模拟时间的储存与计算处理，常与系统函数$time一起使用。 声明格式： time&lt;list_of_register_variables&gt; 1time a,b; //定义了两个64位的时间型变量 ¶2.3.3 实数型 实数型数据在机器码表示法中是浮点型数值，可用于对延迟时间的计算 声明格式： real&lt;list_of_variables&gt; 1real stime; //定义了一个实数型数据 ####2.3.4 参数型 属于常量，在仿真开始之前就被赋值，在仿真过程中保持不变，以提高程序的可读性和维护性 声明格式： parameter&lt;name_of_parameter&gt;=&lt;value&gt; 123parameter length = 32,weight = 16;parameter PI = 3.14,LOAD = 4'b1101;parameter DELAY=(BYTE+BIT)/2; ¶2.3 运算符和表达式 ¶2.3.1 算术运算符 算术运算符包含加法+；减法-；乘法*；除法/；取模% 算术操作结果的算术表达式的结果由最长的操作数决定。在赋值语句下，算术操作结果的长度由操作左端目标长度决定 1234reg[3:0] A,B,C;reg[5:0] D;A = B + C; //4位D = B + C; //6位 有符号数和无符号数的使用 1234567891011121314151617module arith_tb;reg[3:0] a;reg[2:0] b;initial begin a = 4'b1111; //15 b = 3'b011; //3 $display(&quot;%b&quot;,a*b) //乘法运算，结果等于4'b1101,高位被舍去 $display(&quot;%b&quot;,a/b); //除法运算，结果为4'b0101 $display(&quot;%b&quot;,a+b); //加法运算，结果为4'b0010 $diaplay(&quot;%b&quot;,a-b); //减法运算，结果为4'b0010 $diaplay(&quot;%b&quot;,a%b); //取模运算，结果为4'b0000 endendmodule/*注意：二进制的减法先补全位数，使两个数同位，然后再取补码，正二进制数的补码是它本身，负二进制数的补码是它取反后加1*/ ¶2.3.2 相等关系运算符 等于==、不等于！=、全等===、非全等！== 比较的结果有三种，真1、假0、不定值x ==真值表 == 0 1 x z 0 1 0 x x 1 0 1 x x x x x x x z x x x x ===真值表 === 0 1 x z 0 1 0 0 0 1 0 1 0 0 x 0 0 1 0 z 0 0 0 1 ¶2.3.3 条件运算符 表达形式如下： 条件表达式? 表达式1 : 表达式2 条件表达式的计算结果只有1,0和x三种，结果为1时执行表达式1；结果为0时执行表达式2 12345678module mux2(in1,in2,sel,out); input [3:0] in1,in2; input sel; output [3:0] out; reg [3:0] out; assign out = (sel!)?in1:in2; //sel为0时out等于in1，反之等于in2endmodule ¶2.3.4 连接和复制运算符 连接运算符 1{信号1的某几位，信号2的某几位，...，信号n的某几位} 复制操作符 将一个表达式放入双重花括号中，复制因子放在第一层括号中 123456789101112131415161718module con_rep_tb;reg [2:0] a;reg [3:0] b;reg [7:0] c;reg [4:0] d;reg [5:0] e;initial begin a = 3'b101; b = 4'b1110; c = {a,b}; d = {a[2:1],b[2:0]};//d取了a的第3位到2位与b的第3位到1位拼接 e = {2{a}}; $display(&quot;%b&quot;,c); //8'b01011110 $display(&quot;%b&quot;,d); //5'b10110 $display(&quot;%b&quot;,e); //6'b101101 endendmodule ¶2.4 模块 ¶2.4.1 模块的基本概念 模块(module)是Veril HDL语言的基本单元，它代表一个基本的功能块，用于描述某个设计的功能或结构以及与其他模块通信的外部接口 一个模块主要包括： 模块的开始与结束：以关键词module开始，以关键词endmodule结束的一段程序，其中模块开始语句必须要以分号结束 端口定义：用来定义端口列表里的变量哪些是输入(input)、输出(output)和双向端口(inout)以及位宽的说明。 数据类型说明：数据类型在语言上包括wire、reg、memory和parameter等类型，用来说明模块中所用到的内部信号、调用模块等的声明语句和功能定义语句 逻辑功能描述：用来产生各种逻辑(主要是组合逻和时序逻辑)。主要包括以下部分：initial语句、always语句、其它子模块实例化语句、门实例化语句、用户自定义原句(UDP)实例化语句、连续赋值语句(assign)、函数(function)和任务(task) 例：上升沿D触发器 1234567module dff(din,clk,q); input din,clk; output q; reg q; always@(posedge clk) //posedge指D触发器上升沿触发 q &lt;= din;endmodule ¶2.4.2 端口 端口的定义： 模块的端口可以是输入口input、输出端口output或双向端口inout 模块的端口声明了模块的输入输出口。其格式如下： module 模块名(口1,口2,…) 模块的端口表示的是模块的输入和输出口名，也就是说，它与别的模块联系端口的标识。 在模块被引用时，在引用的模块中，有些信号要输入到被引用的模块中，有的信号需要从被引用的模块中取出来。在引用模块时其端口可以用两种方法连接： 在引用时严格按照模块定义的端口顺序来连接，不用标明原模块定义时规定的端口名，例如： 模块名(连接端口1信号名，连接端口2信号名，...) 在引用时用“.”符号，标明原模块是定义时规定的端口名，例如： 模块名(.端口1名(连接信号1名)，.端口2名(连接信号2名)，...) 这样的好处在于可以用端口名与被引用模块的端口相对应，而不必严格按端口顺序对应，提高了程序的可读性和可移植性。","link":"/2020/03/01/FPGA%E5%AD%A6%E4%B9%A0%20%20%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9AVerilog%20HDL%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95(1)/"},{"title":"2020.2.1-2020.2.2 Python基础学习","text":"写在前面 疫情突然降临湖北，欢天喜地的节日气氛变得安静，这几天在家总想学点新东西，由于我学的硬件部分的内容更多，并且有C语言基础，所以决定学习Python这样一个发展前景大、简单实用的语言。 借助廖雪峰的在线学习网站和 《Python编程:从入门到实践》 (非恰饭，勿喷)，在刚开始的两天中，懒懒散散地学习了Python作为一个语言所需要掌握的基本语法，并且简单了解了list、tuple、dict和set这四种数据结构，下列为学习笔记 变量和两种简单数据类型 和学习C语言时一样，上来先得学的是数据类型和变量( 其实学C的时候开始老师先讲了编译原理) ### 1. 变量 - 变量名只能包含字母、数字和下划线。变量名可以字母或者下划线开头，但不能以数字开头 - 变量名不能包含空格，一般用下划线代替空格 - 不要把Python的关键字和函数名当做变量名 - 慎用I和O，因为容易被看成数字1和0 ( 这点确实特别重要hhhh ) 易错点: 123message = 'Wellcome to the World of Python!'print(mesage)#哈哈，日常拼写错误，通假字从古至今从未断绝 ### 2. 字符串string 字符串顾名思义就是一串字符，Python中引用字符串的引号可以是单引号也可以是双引号 #### a. 转义符 在转义符上，Python和C是类似的，因此不作过多解释，只丢几个最基本的在这里 1234print('Hello World!\\n?????')#这里的\\n是换行print('Hello World!\\r What?')#这里的\\r是回车(光标回到起点) 上面两个转义符的效果如下： 123换行转义符'\\n'输出效果Hello World!????? 12回车转义符'\\r'输出效果What? World! #### b. 字符串相关函数 ##### title() title函数用于规整字符串使其符合一般文章标题要求（各个单词首字母大写） 12name = 'hank gan'print(name.title()) 输出结果： 1Hank Gan ##### upper()和lower() upper函数用于将单词的每个字母转化为大写 lower函数用于将单词的每个字母转化为小写 123name = 'Hank Gan'print(name.upper())print(name.lower()) 输出结果： 12HANK GANhank gan ##### 合并/拼接字符串 利用+来拼接不同字符串，使其成为一个新的字符串 1234567message = 'Wellcome to the World of Python!'first_name = 'hank'last_name = 'gan'full_name = first_name + ' ' + last_nameprint('Hello' + ' ' + full_name.title() + ', ' + message) 在上面的print语句中，我用了许多+连接了不同字符串，使同一个print能够打印更多信息，输出结果： 1Hello Hank Gan, Wellcome to the World of Python! ##### 对字符串中空格的操作 在我们或者其他用户向字符串中输入值时，不可避免的会存在输入空格的情况，但有的时候我们的程序在操作过程中不需要这些多余的空格，这时候就需要Python自带的字符串函数来帮忙。 rstrip()、lstrip()和strip() strip是“剔去”的意思，“r”和“l”分别代表左和右，那么这三个函数的作用就通俗易懂了，它们分别是剔除字符串左边、右边、左右两边空格的函数，下面是个小例子： 12345learning = &quot; Python &quot;print(learning.lstrip())print(learning.rstrip())print(learning.strip()) 输出结果： 123Python PythonPython 联想到在转义符那一部分学过的制表符\"，如果将它与上述删除函数结合起来使用的话，就能轻易改变字符串中的空格了 3. 布尔值/Boolean 和C语言不同，Python是具有布尔值的，且Python的布尔值有且仅有True和False。且布尔值的与、或、非运算在Python中表示为and、or、not 123456temp_a = Truetemp_b = Falseprint(temp_a and temp_b)print(temp_a or temp_b)print(not temp_b) 分析： and是与运算，只有当and两边的布尔值全为True时，运算结果才为True，其余全为False or是或运算，当or两边的布尔值有一个为True时，运算结果为True not是非运算，是一种单目运算符，not运算值为取反 运算结果为： 123FalseTrueTrue ## 列表型数据类型list 列表由一系列按特定顺序排列的元素组成，它可以包括字符串、数字，也可以包括其他列表等等数据类型。 在Python中，用方括号[]来表示列表，并用逗号,来分隔其中的元素，例如，用list中套娃list (禁止套娃) 的方式表示出以下几个买不起的山地车品牌： 12other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale'] ### 1. 访问list的方法 #### a. 正向索引 和C语言中的数组一样，通过索引访问list时，索引号是从0开始的，也就意味着整个list的索引号应该是list中元素数目-1 同时，list中的元素若为字符串的话，也可以用上述字符串的各种处理方法来对其进行处理： 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']print(bicycles[0])print('I can not afford a ' + bicycles[3][2].title() + ' ' + 'mountain bike.') 输出结果： 12giantI can not afford a Santa Cruz mountain bike. #### b. 反向索引 如果当一个list中的元素过多，我们想取倒数第一个或者第二个，而不想输入太大的索引号（比如bicycles[9999]这种）的时候，也可以用负数来索引list： 12345678other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']print(bicycles[4])print(bicycles[-1])print(bicycles[3][2])print(bicycles[-2][-1]) 输出结果： 1234cannondalecannondalesanta cruzsanta cruz 对照着list的各个元素索引号就很好理解上述两种索引方式 ### 2. 修改、添加和删除list中的元素 list区别于tuple(后面会写到)的一大区别就是list可以修改，而tuple在定义后就不能够更改了，所以如何修改、添加和删除list中的元素是学习list基础时重点需要掌握的内容。 #### a. 修改list中的元素 修改list中的元素其实很简单，甚至不需要函数来操作，重新定义你想要修改的元素就行了 123456789other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']bicycles[0] = 'dartmoor'print(bicycles[0].upper())'''武汉好像玩DARTMOOR这个牌子山地车的人比较少，玩他家街车的人怪多的他这个牌子全大写，尊重品牌名称，upper''' 第四行代码就是对bicycle这个list的第0号索引值代表的元素进行修改 输出结果： 1DARTMOOR #### b. 向list中添加元素 ##### 在list末尾添加元素 可能这几天我又穷了，连美利达都买不起了，昂贵的自行车品牌中又要添加新成员了怎么办，append()函数可以解决这个问题！ 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']bicycles.append('merida')print('Gosh, I can not afford ' + bicycles[5].title() + ' now.') 穷了的结果： 1Gosh, I can not afford Merida now. 除了能往list末尾添加元素，append()还有一个重要用法是用来动态地构建list： 123456bicycles = [] #首先定义一个需要被构建的listbicycles.append('giant')bicycles.append('trek')bicycles.append('specialized')... 这样的好处是，它可以根据我们的需要随意构建list，而不是在在写下方的代码时再回到一开始定义list的位置添加元素 ##### 在列表中插入元素 有的时候我们想在list中的某一个位置插入元素，而不是在末尾插入，这时候就需要insert()来帮忙了 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']bicycles.insert(0,'merida')print(bicycles[0].title() + '\\n' + bicycles[1].title()) 输出结果： 12MeridaGiant 可见，insert()的第一个参数是指你要把新元素插入到list中，新元素需要被安排的索引号x，插入后，原list在索引号x以后的元素索引号整体后移一位，新元素占据索引号x对应的list中的位置 #### c. 从列表中删除元素 今年收了数量可观的压岁钱，看来咱应该是买得起一辆Giant Reign了，那如何删除列表里的Giant呢？ ##### 知道是第几个元素 如果知道要删除的元素在list中的索引号，那么我们常用del语句来删除元素 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']del bicycles[0]print(bicycles) 有钱了的结果： 1['trek', 'specialized', ['canyon', 'commencal', 'santa cruz'], 'cannondale'] 可见，我们成功删掉了Giant！(确信 ##### 知道这个元素是什么 如果我们知道这个元素是什么，那么我们常用remove()来删除元素 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']bicycles.remove('giant')print(bicycles) 除此之外，我们还可以利用字符串的定义，来更进一步地利用remove()删掉我们想删掉的内容 1234567other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']I_have_bought_it = 'giant'bicycles.remove(I_have_bought_it)print(bicycles)print(I_have_bought_it.title() + ' is not in this list because I have bought it!') 输出结果： 12['trek', 'specialized', ['canyon', 'commencal', 'santa cruz'], 'cannondale']Giant is not in this list because I have bought it! 显然，这样删除Giant更清晰，因为我把删除它的原因也表示出来了，因为我买了它 ##### 虽然要删一个元素，这个元素也想留着 这是什么奇葩要求....离开的就让它离开好嘛，不要再怀念了... 但其实也是做得到的，使用pop()可以在删除某一元素的同时，存储下被删除的这一个元素 这时候的list就像一个栈，而删除list末尾的元素相当于弹出栈顶元素 所以，pop()被称为“删除函数”是有些不恰当的，应该叫做“弹出函数”才对 123456bicycles = ['trek','specialized','santa cruz','giant']print(bicycles)poped_bicycle = bicycles.pop()print(bicycles)print('I have bought ' + poped_bicycle) 输出结果： 123['trek', 'specialized', 'santa cruz', 'giant']['trek', 'specialized', 'santa cruz']I have bought giant 可见，它把被删除的元素保留在了poped_bicycles中，我们仍能访问它 其实，pop()可以弹出任意一个你知道索引号的元素，只需在括号中填入你想要弹出的索引号即可： 12345bicycles = ['trek','specialized','giant','santa cruz']poped_bicycle = bicycles.pop(2)print(bicycles)print('I have bought ' + poped_bicycle) 输出结果： 12['trek', 'specialized', 'santa cruz']I have bought giant ### 3. 组织列表 当我们拿到手一个list，有强迫症的人肯定想做点什么，比如按首字母顺序重新排一下之类的，但是如果真的手动一个一个重新排列的话那岂不是要做到明年去了...Python的动人之处就在于它有各种各样的库，各种各样的函数来简化我们的操作 #### 我有几辆买不起的车？ 虽然我知道我挺穷的，但我还是想知道有多少牌子的山地车是我买不起的，这时候我们就可以用len()来确定一下list的长度。 注意，len()只能确定某一个list有多少元素，而listA中如果还套着一个listB的话，listB中元素的个数是不被计算的，只会把listB当做整个元素看待 12345other = ['canyon','commencal','santa cruz']bicycles = ['giant','trek','specialized',other,'cannondale']print(len(other))print(len(bicycles)) 输出结果： 1235 #### 把我买不起的车排一下序 虽然咱买不起，但总得看着顺眼吧，来排排序？ ##### 永久性排序 使用sort()可以轻松对一个list按照首字母顺序进行排序 1234bicycles = ['trek','specialized','giant','santa cruz']bicycles.sort(reverse = False)print(bicycles) 输出结果： 1['giant', 'santa cruz', 'specialized', 'trek'] 我们成功地排序了这一组list，然而，这个reverse = False是什么意思？查了下词典，reverse的意思是颠倒，那么显然，reverse = False意为不颠倒字母顺序，如果我们要按相反的字母顺序排序的话，sort()中的参数就应该为reverse = True ##### 临时性排序 这些车毕竟买不起，看看就行了，看完了还得给人家放回去，那么如何临时‘看一看’，看完了还能‘放回去’呢？就得请出sorted()来帮忙了 12345bicycles = ['trek','specialized','giant','santa cruz']print(bicycles)print(sorted(bicycles))print(bicycles) 输出结果： 123['trek', 'specialized', 'giant', 'santa cruz']['giant', 'santa cruz', 'specialized', 'trek']['trek', 'specialized', 'giant', 'santa cruz'] 看到没，我只看看，不买，给您还回去了（捂脸.jpg #### 倒着打印 我想玩点花的，我想倒着把我买不起的车子的名字打印出来，但是又懒得一个一个颠倒，有啥办法吗？reverse()就是干这个事的 12345bicycles = ['trek','specialized','giant','santa cruz']print(bicycles)bicycles.reverse()print(bicycles) 输出结果： 12['trek', 'specialized', 'giant', 'santa cruz']['santa cruz', 'giant', 'specialized', 'trek']","link":"/2020/02/05/2020.2.1-2020.2.2%20Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"title":"Verilog HDL 简介与基本语法 2","text":"FPGA学习 阶段一：Verilog HDL 简介与基本语法 2 1. 模块及其结构 Verilog的基本设计单元是“模块”block，一部分描述接口，另一部分描述逻辑功能，比如： 12345678module block(a,b,c,d); input a,b; //描述接口 output c,d; assign c = a | b; //描述逻辑功能 assign d = a &amp; b;endmodule 以上是一个简单的模块，首先描述了四个接口a,b,c,d 之后利用assign语句描述了接口之间的逻辑关系，即c等于a或b，d等于a且b 这样一个完整的模块就定义好了 ### 1.1 功能定义 功能定义部分有三种方法，每个逻辑功能定义之间是并行的关系，即每个功能没有先后顺序，都是同时进行，但每个功能内部中是按照顺序执行的 1. assign语句 assign语句通常用来描述组合逻辑，即可以完整用逻辑门结构来表示的逻辑 2. always语句 always语句不但能描述组合逻辑，还可以用来描述时序逻辑 3. 例化实例元件 如：and #2 u1(q,a,b)定义了一个输入为a和b，输出为q的与门 ### 1.2 模块的调用 在模块调用时，信号通过模块端口在模块之间传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module seg_led_static_top ( input sys_clk , // 系统时钟 input sys_rst_n, // 系统复位信号（低有效） output [5:0] sel , // 数码管位选 output [7:0] seg_led // 数码管段选);//parameter defineparameter TIME_SHOW = 25'd25000_000; // 数码管变化的时间间隔0.5s//wire definewire add_flag; // 数码管变化的通知信号//调用模块//每隔0.5s产生一个时钟周期的脉冲信号time_count #( //列出调用的模块名.MAX_NUM(TIME_SHOW) //列出模块中的参数并重命名) u_time_count( .clk (sys_clk ), //将底层信号传到上层格式： .被调用模块信号名 (顶层信号名) .rst_n (sys_rst_n), .flag (add_flag ));//每当脉冲信号到达时，使数码管显示的数值加1seg_led_static u_seg_led_static ( .clk (sys_clk ), .rst_n (sys_rst_n), .add_flag (add_flag ), .sel (sel ), .seg_led (seg_led ));//被调用模块module time_count( input clk , // 时钟信号 input rst_n , // 复位信号 output reg flag // 一个时钟周期的脉冲信号);//parameter defineparameter MAX_NUM = 25000_000; // 计数器最大计数值//reg definereg [24:0] cnt; // 时钟分频计数器 利用逻辑结构框图，上述模块之间的调用以及信号连接可以表示如下： ## 2. 结构语句 结构语句有initial和always ### 2.1 initial语句 initial语句在模块中只执行一次 它常用于test bench(测试文件)的编写，用来产生仿真测试信号(激励信号)，或者用于对储存器变量赋初值： 12345678910111213initialbegin sys_clk &lt;=1'b0; sys_rst_n &lt;=1'b0; touch_key &lt;=1'b0; //全部拉低 #20 sys_rst_n &lt;=1'b1; //20个单位时间(20ns)后拉高电平 #10 touch_key &lt;=1'b1; #30 touch_key &lt;=1'b0; #110 touch_key &lt;=1'b1; #30 touch_key &lt;=1'b0;endalways #10 sys_clk &lt;= ~sys_clk //每10ns对sys_clk取反一次，也就是说产生周期为20ns，频率为50Mhz的时钟 上面的例子画出波形图如下： 可以看到，实际仿真的波形与我们设定的完全相符，起始状态全部为低电平，sys_clk以周期为20ns为单位不断进行电平反转，20ns后sys_rst_n被拉高，再经过10ns后touch_key被拉高.... ### 2.2 always语句 - always语句一直不停的执行，如上的sys_clk信号，并不是取反一次就结束了，而是不停地进行每10ns取反一次。 - always后紧跟着的是触发条件，触发条件可以是单个信号也可以是多个信号，多个信号中间用or连接，连接而组成的列表称为“敏感列表” - 通常使用的posedge是指上升沿触发，negedge是指下降沿触发 - #### 2.2.1 描述时序逻辑电路 时序逻辑电路中，任一时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态。或者说还与以前的输入有关，因此时序逻辑必须具备记忆功能 123456789101112131415161718192021222324252627282930313233module flow_led( input sys_clk , //系统时钟 input sys_rst_n, //系统复位，低电平有效 output reg [3:0] led //4个LED灯 );//reg definereg [23:0] counter;//计数器对系统时钟计数，计时0.2秒always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter &lt;= 24'd0; else if (counter &lt; 24'd1000_0000) counter &lt;= counter + 1'b1; else counter &lt;= 24'd0;end//通过移位寄存器控制IO口的高低电平，从而改变LED的显示状态always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led &lt;= 4'b0001; else if(counter == 24'd1000_0000) led[3:0] &lt;= {led[2:0],led[3]}; else led &lt;= led;endendmodule 上面的例子很好理解： 如果遇到sys_clk上升沿或sys_rst_n下降沿则进入always语句，然后进行always中的条件判断等等...综合为逻辑框图，可用下图来表示： #### 2.2.2 组合逻辑电路 组合逻辑电路中，任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关 比如，我们可以用always表示一组逻辑门电路： 12345always @(a or b or c or d or e or f or g or h or p or m)begin out1 = a ? (b + c) : (d + e); out2 = f ? (g + h) : (p + m);end 这个逻辑是： 判断a是否为1？若a为1，则out1 = b + c;反之out1 = d + e; 判断f是否为1？若f为1，则out1 = g + h;反之out1 = p + m; 如果组合逻辑快语句的输入变量很多，那么编写敏感列表会很繁琐且容易出错，这时候可以用*来表示对后面语块中所有输入变量的变化都是敏感的 12345always @( * )begin out1 = a ? (b + c) : (d + e); out2 = f ? (g + h) : (p + m);end ### 2.3 赋值语句 在描述组合逻辑的 always 块中用阻塞赋值 = ，综合成组合逻辑的电路结构; 这种电路结构只与输入电平的变化有关系。 在描述时序逻辑的 always 块中用非阻塞赋值 &lt;=，综合成时序逻辑的电路结构; 这种电路结构往往与触发沿有关系，只有在触发沿时才可能发生赋值的变化。 2.3.1 阻塞赋值 阻塞赋值和其他常用语言中赋值的效果相同，即计算RHS(Right Hand Side)并更新LHS(Left Hand Side)，也就是说，在同一个always中，后面的赋值语句是在前一句赋值结束之后才开始赋值的，比如： 123456789101112131415always @(posedge clk or negedge rst_n)begin if(!rst_n) begin a = 1; b = 2; c = 3; end else begin a = 0; b = a; c = b; endend 显然，执行完always后a，b，c都为0，这是因为阻塞时赋值先计算了a = 0，然后再处理了b = a，以此类推，b和c的值都和a相同了 那么有没有办法让b和c赋第一个begin中的值呢？ #### 2.3.2 非阻塞赋值 非阻塞赋值可以看做两个步骤： - 赋值开始的时候计算RHS - 赋值结束的时候更新LHS 通俗来讲，所谓非阻塞是指在计算一个非阻塞赋值的RHS以及更新LHS期间，允许其他非阻塞赋值语句同时计算RHS和更新LHS，也就是说，不同非阻塞赋值语句之间是同时进行的 123456789101112131415always @(posedge clk or negedge rst_n)begin if(!rst_n) begin a &lt;= 1; b &lt;= 2; c &lt;= 3; end else begin a &lt;= 0; b &lt;= a; c &lt;= b; endend 执行以后，b=1，c=2，a=0，可见非阻塞赋值确实是并行的 注意： 在同一个always块中不要既用非阻塞赋值又用阻塞赋值 不允许在多个always块中对同一个变量进行赋值！","link":"/2020/03/14/FPGA%E5%AD%A6%E4%B9%A0%20%20%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9AVerilog%20HDL%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95(2)/"},{"title":"FPGA学习番外篇：在MacOS上编译和仿真verilog","text":"FPGA学习番外篇：在MacOS上编译和仿真verilog 一年没更新了，过去的一年里一直忙着比赛和课业，一直没有更新博客里的内容，从今天开始再填完埋下的坑吧！ 至于为什么会有这个奇怪的番外篇，是因为最近更新了装备，整了台X86的MacBook Pro，为了方便我写verilog和仿真看波形，整合了网上的很多教程最终写出来的。 这其中还包括利用yosys对写好的verilog进行综合的环节，但我想了下，在macOS下烧写fpga十分困难或者对我来说几乎不可能，因此我就虽然写了这部分教程，但我基本没用过综合，非要综合的话利用docker或者虚拟机安装vivado不香嘛😅 OS：macOS Big Sur 11.15.1 Device：MacBook Pro 13 (2020) Software：VScode 假设现在手上拿到的是一台全新的mac，下面将从零开始！ 安装macOS软件包管理工具home brew 类似于linux的apt-get，macOS也有它自己的软件包管理工具home brew，安装方式非常简单，打开终端，输入以下自动运行脚本并根据选项一步步安装即可： 12/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 利用homebrew安装开源verilog编译器icarus-verilog icarus-verilog（下简称iverilog）是一款开源的精巧verilog编译器，可以用它来编译verilog和testbench，并生成仿真波形文件 1brew install icarus-verilog 安装完成后，输入iverilog，出现以下提示即安装成功 123456789Usage: iverilog [-EiSuvV] [-B base] [-c cmdfile|-f cmdfile] [-g1995|-g2001|-g2005|-g2005-sv|-g2009|-g2012] [-g&lt;feature&gt;] [-D macro[=defn]] [-I includedir] [-L moduledir] [-M [mode=]depfile] [-m module] [-N file] [-o filename] [-p flag=value] [-s topmodule] [-t target] [-T min|typ|max] [-W class] [-y dir] [-Y suf] [-l file] source_file(s)See the man page for details. 之后可以使用命令行： 12iverilog -o &quot;testbentch_module.vvp&quot; testbentch_module.v source_module.vvvp -n &quot;testbentch_module.vvp&quot; 或者写一个shell脚本的方式编译verilog和生成波形文件，每次只需要修改文件名即可： 12345678echo &quot;开始编译&quot;source_module=BCD_to_Yusantestbentch_module=BCD_to_Yusan_tbiverilog -o &quot;$testbentch_module.vvp&quot; $testbentch_module.v $source_module.vecho &quot;编译完成&quot;vvp -n &quot;$testbentch_module.vvp&quot;echo &quot;波形文件已生成&quot; 安装波形查看软件/插件 iverilog可以生成vcd格式的波形文件，只需先利用iverilog编译出vvp文件，再在testbench中添加以下代码即可： 123456 /*iverilog */initial begin $dumpfile(&quot;moudule_tb.vcd&quot;); //生成的vcd文件名称 $dumpvars(0, moudule_tb); //tb模块名称end /*iverilog */ 但我们还需要利用软件或者插件读取波形，这里有两种方法： 利用VScode插件查看波形 目前VScode上有两款插件可以看vcd格式的波形，一个是“impulse”，需要先安装jdk，界面稍有些粗糙，且右上角有水印，但胜在它无需付费解锁更多功能： 另一个插件是“WaveTrace“，界面简洁好看，但不付费只能同时看8个信号… 属实很难选择了，不过用VScode插件的话，会很方便，因为可以直接在VScode里点击打开 利用gtkwave看波形 利用软件gtkwave也可以看波形，但需要进入软件后选择文件或者用命令行来打开波形文件，不过可以写shell自动化脚本解决该问题，也是比较方便的。 首先打开terminal安装gtkwave： 1brew install gtkwave 如果安装错误则尝试： 1brew install --cask gtkwave 如果还是报错那就去官网下载安装包手动下载吧（下不下来多半是网络问题） gtkwave官网 之后需要在terminal中添加环境变量，如果以前没有操作过，需要首先注册下bash_profile： 1vim ~/.zshrc 进入以后按i进入插入模式，然后加上： source ~/.bash_profile 之后键入:wq并回车来保存 然后打开bash_profile： 1vim ~/.bash_profile 按上述方法，在其中加上export PATH=“/Applications/gtkwave.app/Contents/Resources/bin:$PATH” 操作完成之后，在terminal输入gtkwave能弹出软件就说明操作成功 如果要打开生成的vcd文件，则需要敲命令行，或者打开软件后在软件中打开文件，不过可以使用自动化脚本解决该问题： 1234567891011echo &quot;开始编译&quot;source_module=BCD_to_Yusantestbentch_module=BCD_to_Yusan_tbiverilog -o &quot;$testbentch_module.vvp&quot; $testbentch_module.v $source_module.vecho &quot;编译完成&quot;vvp -n &quot;$testbentch_module.vvp&quot;echo &quot;波形文件已生成&quot;echo &quot;打开波形文件&quot;gtkwave $testbentch_module.vcd 将上述脚本命名为xx.sh，和写好的module和testbench保存到同一个文件夹，之后在VScode的终端里cd到该文件夹，然后输入./xx.sh+回车即可编译生成和打开波形（我这里命名为ok.sh）： 综合RTL文件 macOS可以利用开源综合器yosys来对RTL文件进行综合： 首先确定你有python3环境，可以在terminal键入python查看 然后在github上clone一份yosys： 1git clone https://github.com/YosysHQ/yosys.git 然后cd进你保存yosys文件的文件夹，安装依赖文件： 1brew tap Homebrew/bundle &amp;&amp; brew bundle 然后编译一份yosys并安装： 12makesudo make install 至此，macOS写/编译/仿真/综合verilog的全套环境都安装完成啦😉","link":"/2021/08/10/FPGA%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E5%9C%A8MacOS%E4%B8%8A%E7%BC%96%E8%AF%91%E5%92%8C%E4%BB%BF%E7%9C%9Fverilog/"},{"title":"FPGA学习：状态机化简&amp;Testbench","text":"FPGA学习 ：状态机及其化简&amp;Testbench 这里练习状态机利用《Verilog HDL高级数字设计》中的一个示例设计，该设计将从低位到高位串行输入的BCD码转换为从低位到高位串行输出的余三码，利用状态机判断每位的状态然后根据输入的数据判断输出数据。具体题目如下： 说句实话，这个题目有点为了用状态机而用状态机的意思了，要将串行输入BCD以余三码串行输出的方式我能想到的其实很简单，完全不需要状态机，用四个DFF做缓冲串转并，然后把转完的数加上0011即可，最后再用四个DFF并转串输出。 但是人家既然要求了要用状态机，那就做呗，顺便研究下状态机化简😅 状态转移图及其化简 首先根据题目条件，将依次从低到高输入4个2进制数，那也就意味着从状态机的开始状态需要再接收四个数据才能回到开始状态，那么这将是一个有四层递进关系树的状态机，结合每一位的真值表，可以将这个状态机的状态转移图画出来： 看上图可以知道，这个状态机显然有很多可以化简的地方，那么具体什么条件下可以将状态机化简/什么情况下两个状态等价呢？ 其实这本书上也明确讲了，即如果两个状态对于相同的输入序列，都有相同的输出序列和下一状态，那么这两个状态称为等价状态，在转移图中可以只保留其中一个。 那么接下里就可以开始状态化简，一般先从最底层分支开始，即绿色部分的状态，下面都是显而易见的相同状态： S6和S10都是输入将输入直接输出(输入0输出0，输入1输出1)，且下一状态均为IDLE S7/S8/S2都是将输入直接输出(输入0输出0)，且下一状态均为IDLE S9/S11/S13都是将输入取反输出，且下一状态均为IDLE 可见，上面列举的第一种和第二种状态其实也可以看作同种状态，因为在这个题里，输入BCD是不会超过9的，因此将绿色状态化简，只保留两个状态即可，即输入和输出相同以及输入和输出相反，如下图所示： 接下来再化简粉红色部分状态： S3/S4/S5都是输入0输出1转换到S6；输入1输出0转换到S9(这也太巧了) 那么就轻而易举地化简这一步状态了，最后最简的状态如下图： 化简完就可以进行下一步了 状态机结构设计 状态机分为一/二/三段式三种状态机，一段式状态机很少用，经常使用的是二段和三段式状态机 二段式状态机的第一段是当前状态转移，第二段是下一状态获取以及输出 三段式状态机的第一段是当前状态转移，第二段是下一状态获取，第三段是输出 这里演示一下二段式状态机的写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576`timescale 1ns/100psmodule BCD_to_Yusan #( parameter STATE_NUM = 3 )( input wire B_in, input wire clk, input wire rstn, output wire B_out); parameter IDLE = 3'b000;parameter STATE_0 = 3'b001;parameter STATE_1 = 3'b010;parameter STATE_2 = 3'b011;parameter STATE_3 = 3'b100;parameter STATE_4 = 3'b101;parameter STATE_5 = 3'b110;reg [STATE_NUM - 1 : 0 ] STATE_NOW = 0;reg [STATE_NUM - 1 : 0 ] STATE_NEXT = 0;//!fsm_extractalways @(posedge clk or negedge rstn) begin if (!rstn) begin STATE_NOW = IDLE; end else begin STATE_NOW = STATE_NEXT; endendreg B_out_r;//!fsm_extractalways @(posedge clk) begin case (STATE_NOW) IDLE: case (B_in) 1'b0: begin STATE_NEXT = STATE_0; B_out_r = !B_in; end 1'b1: begin STATE_NEXT = STATE_1; B_out_r = !B_in; end default: STATE_NEXT = IDLE; endcase STATE_0: case (B_in) 1'b0: begin STATE_NEXT = STATE_2; B_out_r = !B_in; end 1'b1: begin STATE_NEXT = STATE_3; B_out_r = !B_in; end default: STATE_NEXT = IDLE; endcase STATE_1: begin STATE_NEXT = STATE_3; B_out_r = B_in; end STATE_2: begin STATE_NEXT = STATE_4; B_out_r = B_in; end STATE_3: case (B_in) 1'b0: begin STATE_NEXT = STATE_4; B_out_r = !B_in; end 1'b1: begin STATE_NEXT = STATE_5; B_out_r = !B_in; end default: STATE_NEXT = IDLE; endcase STATE_4: begin STATE_NEXT = IDLE; B_out_r = B_in; end STATE_5: begin STATE_NEXT = IDLE; B_out_r = !B_in; end default: STATE_NEXT = IDLE; endcaseendassign B_out = B_out_r;endmodule 如果需要改成三段式状态机，只需要将上面代码第二段的输出全部提出来，另写一个always块即可 Testbench仿真激励的设计 设计这个题目的testbench的时候，我一开始是想在rst之后，直接手动这么写： 1234567891011121314151617initial begin rstn = 1'b1;#5 rstn = 1'b0;#5 rstn = 1'b1;//B_in从低到高输入0011 B_in = 1'b1；#5 B_in = 1'b1；#5 B_in = 1'b0；#5 B_in = 1'b0；end//clock generatingreal CYCLE_200MHz = 5 ; //200Mhz ~ 5nsalways begin clk = 0 ; #(CYCLE_200MHz/2) ; clk = 1 ; #(CYCLE_200MHz/2) ;end 但是显而易见这种手动输入的方式有个很大的缺点，我写testbench肯定是想把每种情况都test一遍，而且还得测试连续输入连续输出的情况，如果每种情况都这样一个个改B_in的话显得太笨拙太没效率了，那该咋办呢？ 那其实很简单，我们在testbench里生成一块memory，把10种BCD码保存在外部文件，然后在testbench里把文件加载到memory就行了： 12345parameter ADDR_SIZE = 10 , WORD_SIZE = 4;reg [WORD_SIZE - 1:0] Ram[0:ADDR_SIZE - 1]; //存储器：生成10个4位寄存器,在verilog2005中，内存存储从左侧数字开始分配，因此左侧值为0initial begin $readmemb(&quot;BCD.txt&quot;,Ram); //readmemb读二进制文件，readmemh读16进制文件end 其中，BCD.txt里保存如下内容： 123456789100000000100100011010001010110011110001001 然后再利用循环语句将这些数据赋值给B_in即可，注意，要从低位开始赋值！： 1234567always @(posedge clk ) begin B_in = Ram[addr_count][word_count]; if (word_count == 1'b0) begin word_count = 3'b011; addr_count = addr_count + 1'b1; end else word_count = word_count - 1'b1; //verilog没有++和--end 当然，verilog里的循环语句不止有repeat，还有while,for,forever等等 为了确认我们这样操作是否正确，还可以通过$write和$display在终端里先看一眼是不是我们要输入给B_in的数据，以及它们是不是从低到高输入的 注意，$write和$display的不同点在下面代码块的注释中提到了 123456789101112131415initial begin addr_count = 1'b0; word_count = 3'b011; //以下代码作用是四个bit为1组，打印10组数,从低位开始输出 repeat(40) begin $write(&quot;%b&quot;,Ram[addr_count][word_count]); //display自动换行，write需要加换行符 if (word_count == 1'b0) begin $write(&quot;\\n&quot;); word_count = 3'b011; addr_count = addr_count + 1'b1; end else word_count = word_count - 1'b1; //verilog没有++和-- end #250 $finish;end 最后我把整个testbench和仿真出来的波形附在下面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970`timescale 1ns/100psmodule BCD_to_Yusan_tb; parameter ADDR_SIZE = 10 , WORD_SIZE = 4; // Ports reg B_in; reg clk = 0; reg rstn = 1; reg [3:0] count; reg [WORD_SIZE - 1:0] word_count; reg [ADDR_SIZE - 1:0] addr_count; wire B_out; reg [WORD_SIZE - 1:0] Ram[0:ADDR_SIZE - 1]; //存储器：生成10个4位寄存器,在verilog2005中，内存存储从左侧数字开始分配，因此左侧值为0 BCD_to_Yusan tb ( .B_in (B_in ), .clk (clk ), .rstn (rstn ), .B_out ( B_out) ); /*iverilog */initial begin $dumpfile(&quot;BCD_to_Yusan_tb.vcd&quot;); //生成的vcd文件名称 $dumpvars(0, BCD_to_Yusan_tb); //tb模块名称end /*iverilog */initial begin $readmemb(&quot;BCD.txt&quot;,Ram); //readmemb读二进制文件，readmemh读16进制文件endinitial begin rstn = 1'b0; #5rstn = 1'b1; addr_count = 1'b0; word_count = 3'b011; //以下代码作用是四个bit为1组，打印10组数,从低位开始输出 repeat(40) begin $write(&quot;%b&quot;,Ram[addr_count][word_count]); //display自动换行，write需要加换行符 if (word_count == 1'b0) begin $write(&quot;\\n&quot;); word_count = 3'b011; addr_count = addr_count + 1'b1; end else word_count = word_count - 1'b1; //verilog没有++和-- end addr_count = 1'b0; word_count = 3'b011; #250 $finish;endalways @(posedge clk ) begin B_in = Ram[addr_count][word_count]; if (word_count == 1'b0) begin word_count = 3'b011; addr_count = addr_count + 1'b1; end else word_count = word_count - 1'b1; //verilog没有++和--end//clock generatingreal CYCLE_200MHz = 5 ; //200Mhz ~ 5nsalways begin clk = 0 ; #(CYCLE_200MHz/2) ; clk = 1 ; #(CYCLE_200MHz/2) ;end endmodule","link":"/2021/08/11/FPGA%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8C%96%E7%AE%80-Testbench/"},{"title":"Python基础：操作list以及tuple的引入","text":"又是一篇臭长臭长的....下次尽量拆开来写吧 # 遍历整个列表 在C语言中，我们如何实现“遍历”这一操作呢？答案显而易见，使用循环。在Python中同理，我们要对列表中的每一个元素进行操作，那么就需要遍历整个list，而要遍历整个list，循环语句是不可缺少的。 ## 1. 循环 还是以那些我买不起的自行车品牌为例，假如现在我需要把列表bicycles中的所有元素一一打印出来，需要怎么操作呢？ 1234bicycles = ['trek','specialized','giant','santa cruz']for bicycle in bicycles: print(bicycle) - 首先定义一个列表bicycles - 紧接着定义一个for语句，这行代码让Python从列表bicycles中取出一个元素(这里是自行车品牌)，并将其存储在变量bicycle中 - 最后，让python打印前面储存在变量bicycle中的变量即可 输出结果： 1234trekspecializedgiantsanta cruz 可以看出来，我们达到了一一打印整个list中的元素的目的，for语句循环地执行，直到列表中的元素全部被执行过为止。 但这里有一个细节令人注意：为什么第四行代码print语句前会有一个缩进？ ## 2. 缩进 用过Word系列办公工具的同学可能知道缩进，在电脑上敲出缩进的方法通常为：在编辑过程中按下键盘上的tab键。那么缩进在Python中是做什么的，有什么意义呢？ Python是根据缩进来判断代码行与前一个代码行的关系的，如果一行代码前有缩进，那么意味着这行代码被包含于上一个没有缩进的代码行中。看起来有点不好理解，下面来演示一下这到底是什么意思。 ### a. 在for循环中执行更多操作 有的时候，我们不仅想要打印出列表中的内容，还想在此基础上增加一句别的内容，如何处理呢？ 12345bicycles = ['trek','specialized','giant','santa cruz']for bicycle in bicycles: print('The ' + bicycle.title() + ' bicycle is so great!') print(&quot;I can't wait to buy a &quot; + bicycle.title() +' bike') 输出效果： 12345678The Trek bicycle is so great!I can't wait to buy a Trek bikeThe Specialized bicycle is so great!I can't wait to buy a Specialized bikeThe Giant bicycle is so great!I can't wait to buy a Giant bikeThe Santa Cruz bicycle is so great!I can't wait to buy a Santa Cruz bike 可见，for语句后的两个print前都使用了相同的缩进，意味着这两个print语句都被包含于同一个for语句下 ### b. 在for循环后执行更多操作 如果我并不想在每一次循环中都输出，而只想在最后一次循环后输出怎么办呢？ 12345bicycles = ['trek','specialized','giant','santa cruz']for bicycle in bicycles: print('The ' + bicycle.title() + ' bicycle is so great!')print(&quot;I can't wait to buy a &quot; + bicycle.title() +' bike') 可以看到，现在的代码中，第二个print语句前并没有缩进，因而不会被包含在循环语句中，所以，只有当循环语句执行完毕之后才会进入第二个print语句中。 输出结果： 12345The Trek bicycle is so great!The Specialized bicycle is so great!The Giant bicycle is so great!The Santa Cruz bicycle is so great!I can't wait to buy a Santa Cruz bike ## 3. 数字列表 有的时候，我们仅仅想处理数字内容，但又不想如此麻烦的初始化列表，这时该如何做呢？ ## range()函数的用法 Python的自带函数range()可以轻松的生成一段数字列表，它的语法如下： 1234#range(start, stop[, step])#单参数时：for value in range(5): print(value) 输出结果： 1234501234 单参数时，默认的起点start为0，传入的参数为结束点，步进值默认为11234#range(start, stop[, step])#双参数时：for value in range(1,5): print(value) 输出结果： 12341234 双参数时，传入的参数分别为起点start和终点stop，步进值同样默认为11234#range(start, stop[, step])#三参数时：for value in range(1,5,2): print(value) 输出结果 1213 这个时候，三个参数都将被自定义，分别为起点start、终点stop和步进值step### 创建数字列表 明白了range()的用法后，创建数字列表的方法好像呼之欲出了，但还是少了点什么。在Python中，有一类函数地作用是将数据类型转换，比如int()是将传入的参数转换为int型数据。那么是不是可以用同样形式的list()来生成列表型数据呢？当然可以： 12numbers = list(range(1,6))print(numbers) 输出结果： 1[1, 2, 3, 4, 5] 可见，我们的想法是正确的，确实可以这样生成数字型list，下面是我们常用的定义一个数字型list的方法： 1234squares = []for square in range(1,11): squares.append(square**2)print(squares) 这里我们想创建一个包含1~10的平方数的数字型list，其中**指的是平方运算，这几行代码的输出结果为： 1[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ### 数字列表的简单统计计算 有的时候我们需要找到一个数字型list中的最大值、最小值和均值==总和，如果是在C语言中，我们可能会用循环语句来做，但是在Python中，我们可以使用现有函数来完成它： 1234statistics = [1,2,4,9,12,435,1,23,34,123,45645,2312,35,123,675,345,23434,45]print('最大值为' + str(max(statistics)))print('最小值为' + str(min(statistics)))print('总和为' + str(sum(statistics))) 输出结果： 123最大值为45645最小值为1总和为73258 ## 4. 列表的切片 有的时候我们并不想处理整个列表，而是想处理列表中的部分内容，这该怎么做呢？这时候就应该使用我们的切片工具。 ### 切片 下面，我只想打印出从第一个到第三个我买不起的自行车品牌： 12bicycles = ['giant','trek','specialized','santa cruz','cannondale']print(bicycles[0:3]) 输出结果： 1['giant', 'trek', 'specialized'] 值得注意的是，切片时传入的**第一个**参数和索引号是一一对应的，而第二个参数为索引号+1。 也就是说，如果想从第1个元素开始，那么第一个参数应该是0而非1；如果想终止于第4个元素，那么第二个参数就是4如果参数不填的话，索引的第一个参数默认为0，第二个值默认为列表中元素的个数 同样，与列表的索引方式相同，也可以用负索引号来完成切片： 1234bicycles = ['giant','trek','specialized','santa cruz','cannondale']print(bicycles[:3])print(bicycles[2:])print(bicycles[-3:3]) 输出结果： 123['giant', 'trek', 'specialized']['specialized', 'santa cruz', 'cannondale']['specialized'] ### 遍历切片 如果要遍历列表中的部分元素，可以在for循环中使用切片： 123bicycles = ['giant','trek','specialized','santa cruz','cannondale']for bicycle in bicycles[1:4]: print(bicycle.title()) 输出结果： 123TrekSpecializedSanta Cruz 这样就可以实现在整个列表中进行部分操作，而非整个列表一起操作 ## 5. 列表的复制 有的时候需要根据现有的list创建新的list，就需要用到列表的复制。 要复制list，可以创建一个包含整个list的切片，方法是：同时省略起始索引和终止索引[:]。这样就可以创建一个始于第一个元素，终于最后一个元素的列表。 1234bicycles = ['giant','trek','specialized','santa cruz','cannondale']my_bicycles = bicycles[:]print(my_bicycles) 输出结果： 1['giant', 'trek', 'specialized', 'santa cruz', 'cannondale'] 可能有的人会疑惑了，为什么要这样花里胡哨的复制列表呢？直接list1 = list2不好嘛？ 确实，这样确实可以得到相同的列表，但是这步操作并不是我们想要的\"复制\"，而仅仅是更换了列表的变量名，什么意思呢？看下面的操作就明白了： 12345678bicycles = ['giant','trek','specialized','santa cruz','cannondale']my_bicycles = bicyclesbicycles.append('specialized')my_bicycles.append('polygon')print(bicycles)print(my_bicycles) 输出结果： 12['giant', 'trek', 'specialized', 'santa cruz', 'cannondale', 'specialized', 'polygon']['giant', 'trek', 'specialized', 'santa cruz', 'cannondale', 'specialized', 'polygon'] 可以看到，我明明是对两个list进行不同的操作，一个增加了specialized，另一个增加了polygon，但是输出的结果却是一样的，这是因为直接粗暴地list1 = list2只是更换了变量名，无论如何操作都只操作同一个list。而用切片的方法才能在真正意义上新建一个相同列表： 12345678bicycles = ['giant','trek','specialized','santa cruz','cannondale']my_bicycles = bicycles[:]bicycles.append('specialized')my_bicycles.append('polygon')print(bicycles)print(my_bicycles) 输出结果： 12['giant', 'trek', 'specialized', 'santa cruz', 'cannondale', 'specialized']['giant', 'trek', 'specialized', 'santa cruz', 'cannondale', 'polygon'] 实践才是检验真理的唯一标准!!!! # 元组 元组型数据结构tuple与列表型list最大的不同就在于，**列表中的元素是可以被修改的**，如增加、删除、替换等，而**元组中的任何一个元素在被定义后就不可被修改**。 且**列表是用中括号[]来定义的，而元组是用小括号()来定义的** 但是这不意味着元组本身是不可修改的，元组是可以被删除的，只不过元组中的元素是不可删除的。元组也可以进行类似列表的拼接、索引、求最大/最小值等等。 由于tuple型和list`型的操作大同小异，因此在这里只描述一下如何定义元组，不再进行深入拓展： 123bicycles = ('giant','trek','specialized','santa cruz','cannondale')print(bicycles) 输出结果： 1('giant', 'trek', 'specialized', 'santa cruz', 'cannondale')","link":"/2020/02/14/Python%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%93%8D%E4%BD%9Clist%E4%BB%A5%E5%8F%8Atuple%E7%9A%84%E5%BC%95%E5%85%A5/"},{"title":"为什么我选择了Python","text":"为什么我选择了Python 目前，Python语言的发展势头在国内国外都是不可阻挡的，Python凭借其简单优雅的语法，强大的生态圈从众多语言中脱颖而出，如今已经是稳坐编程语言排行榜前三的位置。国内很多Python开发者都是从Java开发者跨界过来的，我自己也不例外。我简单的跟大家交代一下，我为什么选择了Python。 Python vs. Java 我们通过几个例子来比较一下，做同样的事情Java和Python的代码都是怎么写的。 例子1：在终端中输出“hello, world”。 Java代码： 123456class Test { public static void main(String[] args) { System.out.println(&quot;hello, world&quot;); }} Python代码： 1print('hello, world') 例子2：从1到100求和。 Java代码： 12345678910class Test { public static void main(String[] args) { int total = 0; for (int i = 1; i &lt;= 100; i += 1) { total += i; } System.out.println(total); }} Python代码： 1print(sum(range(1, 101))) 例子3：双色球随机选号。 Java代码： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.List;import java.util.ArrayList;import java.util.Collections;class Test { /** * 产生[min, max)范围的随机整数 */ public static int randomInt(int min, int max) { return (int) (Math.random() * (max - min) + min); } public static void main(String[] args) { // 初始化备选红色球 List&lt;Integer&gt; redBalls = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 33; ++i) { redBalls.add(i); } List&lt;Integer&gt; selectedBalls = new ArrayList&lt;&gt;(); // 选出六个红色球 for (int i = 0; i &lt; 6; ++i) { selectedBalls.add(redBalls.remove(randomInt(0, redBalls.size()))); } // 对红色球进行排序 Collections.sort(selectedBalls); // 添加一个蓝色球 selectedBalls.add(randomInt(1, 17)); // 输出选中的随机号码 for (int i = 0; i &lt; selectedBalls.size(); ++i) { System.out.printf(&quot;%02d &quot;, selectedBalls.get(i)); if (i == selectedBalls.size() - 2) { System.out.print(&quot;| &quot;); } } System.out.println(); }} Python代码： 12345678910111213141516from random import randint, sample# 初始化备选红色球red_balls = [x for x in range(1, 34)]# 选出六个红色球selected_balls = sample(red_balls, 6)# 对红色球进行排序selected_balls.sort()# 添加一个蓝色球selected_balls.append(randint(1, 16))# 输出选中的随机号码for index, ball in enumerate(selected_balls): print('%02d' % ball, end=' ') if index == len(selected_balls) - 2: print('|', end=' ')print() 相信，看完这些例子后，你一定感受到了我选择了Python是有道理的。","link":"/2020/01/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86Python/"},{"title":"字典(dict)型数据结构","text":"字典(dict)型数据结构 在C语言中，结构体可以将变量与变量之间相关联地储存起来，Python中也有与之类似的一种结构，叫做字典(dict)，它能将键key与值value一一对应然后储存起来。 ## 1.字典的建立 前面学过的总结一下： 列表list = ['element_1','element_2',...] 元组tuple = ('element_1','element_2',...) 字典的表示方式为：dict = {'key_1':'value_1','key_2':'value_2',...} ### 直接定义 设计一个游戏，其中包含一些外星人，这些外星人的颜色和分数各不同，我们要存储这些信息就需要用到字典： 1234alien_0 = {'color':'green','points':5}print(alien_0['color'])print(alien_0['points']) 这样就可以初步的建立起了一个dict型结构，传入一个key，其对应的value就被打印出来： 12green5 ### 定义后添加 和列表相同，字典也可以在定义后添加key-value来达到构建字典的目的： 123456789101112131415#部分定义alien_0 = {'color':'green','points':5}alien_0['x_position'] = 0alien_0['y_position'] = 25print(alien_0)#空定义alien_0 = {}alien_0['color'] = 'green'alien_0['points'] = 5alien_0['x_position'] = 0alien_0['y_position'] = 25print(alien_0) 1{'color': 'green', 'points': 5, 'x_position': 0, 'y_position': 25} ## 2. 修改字典中的value 123456789101112#更改dict中的valuealien_0 = {'color':'green'}print('The alien is ' + alien_0['color'] + '.')alien_0['color'] = 'yellow'print('The alien is ' + alien_0['color'] + '.')#利用del语句删除key-valuealien_0 = {'color':'green','points':5}print(alien_0)del alien_0['points']print(alien_0) 123456#更改dict中的valueThe alien is green.The alien is yellow.#利用del语句删除key-value{'color': 'green', 'points': 5}{'color': 'green'} 注意：删除了的key-value永远消失，操作是不可逆的 ## 3. 遍历字典 由于字典是由一个或者无数个key-value构成的，因此在遍历的时候要首先确定需要遍历的是什么，是key-value还是key，或者只是value： 123456789101112131415161718192021222324#遍历所有的key-value -&gt; dict.items()user = { 'username':'hank.gan@foxmail.com', 'passport':'123456', 'verification code':'SC9D'}for key,value in user.items(): #此处的key、value可以是任何变量名 print('\\nkey: ' + key) print('value: ' +value) #遍历所有的key -&gt; dict.keys()user = { 'username':'hank.gan@foxmail.com', 'passport':'123456', 'verification code':'SC9D'}for key in user.keys(): print('key: ' + key) #遍历所有的value -&gt; dict.values()user = { 'username':'hank.gan@foxmail.com', 'passport':'123456', 'verification code':'SC9D'}for value in user.values(): print('value: ' +value) 1234567891011121314151617181920#遍历所有的key-value -&gt; dict.items()key: usernamevalue: hank.gan@foxmail.comkey: passportvalue: 123456key: verification codevalue: SC9D#遍历所有的key -&gt; dict.keys()key: usernamekey: passportkey: verification code#遍历所有的value -&gt; dict.values()value: hank.gan@foxmail.comvalue: 123456value: SC9D ### 集合set 此处需要补充一下集合的内容。和它的名字一样，集合set具有数学中集合类似的意义：set中的元素不能有重复。set是用来存放key的，因此可以得出key也是一个唯一且不重复的值，那么如果定义了两遍同一个key会怎么样呢？详见上述修改字典的value 下面一个简单的例子来说明set的作用： 12345678favourite_bikes = { 'hank':'santa cruz', 'jack':'giant', 'tim':'specialized', 'phill':'giant', 'edward':'specialized'}for value in set(favourite_bikes.values()): print(value) 123specializedgiantsanta cruz 可见，无论一个value在list或dict中重复多少次，在转化为set后都有且只有一个 ## 4. 字典的嵌套 ### a. 字典列表 如果一个项目存在多个类似的字典，而又需要统一管理它们，比如在攻击外星人这种游戏中关于外星人的设定，我们可以用一个总体列表来表示外星人这一群体： 12345678alien_0 = {'color':'green','points':5}alien_1 = {'color':'yellow','points':10}alien_2 = {'color':'red','points':15}aliens = [alien_0,alien_1,alien_2]for alien in aliens: print(alien) 123{'color': 'green', 'points': 5}{'color': 'yellow', 'points': 10}{'color': 'red', 'points': 15} 可见，我们仅用一个列表就将所有字典包含起来了，这要操作就方便很多 实际上，我们可能需要自动生成更多外星人，引入range()可以解决这个问题并且可以用条件语句和切片来对字典的value进行修改： 12345678910111213141516171819aliens = []for alien_number in range(30): new_alien = {'color':'green','points':5} aliens.append(new_alien)#第四个外星人后属性改变for alien in aliens[3:8]: if alien['color'] == 'green': alien['color'] = 'yellow' alien['points'] = 10#第八个外星人后属性改变for alien in aliens[7:]: if alien['color'] == 'green': alien['color'] = 'red' alien['points'] = 15#显示修改后的情况for alien in aliens[:10]: print(alien) 123456789{'color': 'green', 'points': 5}{'color': 'green', 'points': 5}{'color': 'yellow', 'points': 10}{'color': 'yellow', 'points': 10}{'color': 'yellow', 'points': 10}{'color': 'yellow', 'points': 10}{'color': 'yellow', 'points': 10}{'color': 'red', 'points': 15}{'color': 'red', 'points': 15} 显然，通过综合运用各种方式，我们的目的达到了 ### b. 字典中嵌套列表 如果同一个key对应多个value，比如，加在披萨中的配料可能不止一种，怎么办？这个时候就需要在字典中嵌套列表来实现： 123456pizza = { 'crust':'thick', 'toppings':['mushrooms','extra cheese']}print('You ordered a ' +pizza['crust'] + '-crust pizza' + 'with the following toppings:')for topping in pizza['toppings']: print('\\t' + topping) 123You ordered a thick-crust pizzawith the following toppings: mushrooms extra cheese ### c. 在字典中嵌套字典 比如我们需要用爬虫爬取一个网站，但是要用不止一个以上的用户名登录，这个时候就可以用字典嵌套字典： 123456789101112131415users = { 'hank':{ 'username':'hank.gan@foxmail.com', 'passport':'123456', 'verification code':'SC9D' }, 'tim':{ 'username':'tim.cook@foxmail.com', 'passport':'654321', 'verification code':'BVR3' }}for user,user_info in users.items(): print('Hello, ' + user.title() +' Your email is ' + user_info['username'] + '.And your passport is ' + user_info['passport'] + '.Please fill the verification code: ' + user_info['verification code'] + '.') 12Hello, Hank Your email is hank.gan@foxmail.com.And your passport is 123456.Please fill the verification code: SC9D.Hello, Tim Your email is tim.cook@foxmail.com.And your passport is 654321.Please fill the verification code: BVR3. 有内味了蛤hhhhh其实用爬虫的时候填表单正是用的字典来完成。","link":"/2020/02/18/%E5%AD%97%E5%85%B8(dict)%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"气泡船电路板设计及其所接外设硬件原理","text":"# [2020节能减排]气泡船电路板设计及其所接外设硬件原理 气泡船电路板的前期设计规划 设备 数量 供电 控制方式 动力电机 2 24V供电 120W额定功率 PWM+5V+方向IO+GND 船方向舵机 2 24V供电 约 24W功率 PWM+5V+GND x 2 迪文串口屏 1 5-15V供电 232电平串口通信 mpu6050角度/加速度 1 3.3V供电 I2C通信 气泵 1 12V供电 35W额定功率 PWM占空比控制喷气量 电磁阀 1 12V电压 开关，常闭，继电器/MOS管控制 一个IO口 流量计 1 5V供电 IO口测频率 移动配载平台 1 12V供电 约36W功率 PWM + 5V+方向IO 电流传感器 1 3.3V供电 I2C通信 WiFi通信 1 3.3V供电 TTL串口通信 以上是气泡船预计所要接的全部外设，结合上述统计，分配供电，作出下列框图： 接下来对每一个外设硬件进行原理讲述 外设硬件原理描述 1.动力电机 选用的动力电机为时代超群直流无刷伺服电机，这个电机自带编码器和驱动，因此我们不需要考虑丢步的问题，同时，也因为自带了驱动，控制方面也很简单，只需要控制电机的正反转和电机的速度即可。 因此，控制动力电机只需要开一个PWM通过调节占空比来进行速度调整，再开一个I/O进行方向控制即可 通过给PU的脉冲的占空比来控制转速，占空比转速范围10% ~ 90%代表 0 ~ Max_ Speed1 。PU的频率为1K~ 10K任意值 \\[PU占空比 = (目标转速/3000) * 0.8 + 0.1\\] 例如，如果我要设置转速为2000，那么占空比应为\\[PU2000 = (2000/3000) * 0.8 + 0.1 = 0.633\\] 控制方向的I/O只需要输出高低电平就能达到目标 综上，分别打开PE9和PE11这两个连接在TIM1上的PWM输出通道分别控制左右两个动力电机的速度，PE10和PE12分别控制左右两个动力电机的方向。 2.船方向舵机 方向舵机的控制原理与动力电及类似，且相较于动力电机，它少了一个控制正反转的接口，是因为舵机是靠检测输入的PWM占空比来转动相应角度的，也就是说，每一个占空比对应一个固定的角度，因此，要控制它的正反转只需要改变占空比的大小即可。 综上，分别打开PA1和PA2这两个连接在TIM2上的PWM输出通道分别控制左右两个舵机的角度 3.迪文串口屏 选用的为DMT10768T097_19WT的9.7寸工业级串口屏。这个串口屏的通信采用232电平下的UART串口通信，因此在主控板上需要加一个MAX232电平转换芯片，MAX232的原理点击这里，那么控制它就简单了，只需要单片机引出一对UART通信接口，再将通信接口连到MAX232转换一下电平即可，下面是设计的原理图： 其中，DISPALY TX/RX接在串口屏上，Screen TX/RX分别接在PC10和PC11 4.mpu6050 mpu6050实际上就是两个传感器，一个陀螺仪角度传感器，一个加速度传感器。陀螺仪的原理是，一个旋转物体的旋转轴所指的方向在不受外力影响时不会改变，利用这个特性，可以精确地确定运动物体的方位。而加速度传感器的原理是，传感器在加速过程中，通过对质量块所受惯性力的测量，利用牛顿第二定律获得加速度值。 mpu6050和嵌入式控制器之间的通信方式为I2C通信，其本质是一根数据线，一根时钟线，通过时钟线保持mpu6050与嵌入式控制器时钟信号的同步，然后利用数据线进行数据传输。注意一点，STM32要能随意地读取mpu6050采集到的信息，所以在编写程序的时候mpu6050应该是I2C通信的从机，而STM32应该是主机。但一般mpu6050的驱动程序已经封装好了，各种寄存器和通信方式都已经配置地很成熟，无需再从零开始造轮子。 综上，分别打开PB10和PB11这一组硬件I2C接口，既然STM32这么高级，都有硬件I2C了，为啥还需要大费周章一行一行的写I2C时序代码呢(摊手.jpg 5.气泵 气泵也许是这个项目最简单的被控器件了，可惜并不是 在小组讨论以后，按照指导老师的要求，我们本该寻找一种可以控制开合程度的电磁阀来控制喷气速率的，但是遗憾的是，我们翻遍了整个淘宝都没找到这种高级的电磁阀(仿佛嗅到了商机 因此，我不得不调整一下思路，既然不能在传播过程中控制喷气速率，那就只能在源头上解决了。 所以，对气泵的控制方式显得格外重要。结合模电学过的MOSFET的知识，可以知道，MOS管是个通过改变栅源电压VGS控制漏极电流ID的器件： 利用其转移特性，我们可以通过控制栅源电压有效值来改变输入气泵的电流，以此来改变气泵的功率（气泵输入电压为12V定值），进而达到了控制喷气量的目的。 控制栅源电压的有效值就更简单了，我们只需要让STM32输出一组PWM，改变PWM的占空比即可改变输出电压有效值，为了让控制效果更直观，可以加一个LED显示电流大小。 选型费了不少功夫，我预期的安全电流ID为10A，VGS为10V，找到了AOD4184这一款NMOS 但它的限制功率可能有些低，于是将两个相同的AOD4184并联就行了，再加上限流电阻等等元器件，设计好的具体原理图如下 于是，整个气泵的控制模块就被设计出来了，通过STM32上连接在TIM3的PA6引脚输出可控占空比的PWM波，通过一个限流电阻输入到两个并联NMOS的栅极，来控制连接在12V气泵的电流/功率大小，进而控制喷气量。 6.电磁阀 事实证明，电磁阀才是最容易控制的器件 电磁阀的控制只用到了一个I/O口，利用其高低电平的输出来控制电磁阀的通断。 7.流量计 我们选用了这一款流量计，它是利用气流对流量计内部的一个小涡轮冲击使其旋转，旋转的情况被侧边的霍尔传感器感知，然后产生一个方波，我们通过读出输入STM32的方波频率就可以知道气体流量了，具体公式如下 \\[f=(5.5*Q)\\] \\[Q=L/Min\\] 注意：这里的设计有问题，在实际组装器件的时候给流量计的供电是3.3V，否则有可能会烧坏STM32 为了读出流量计霍尔元件产生的方波频率，打开了一个外部中断I/O，对应管脚PA3，通过定时器外部中断，每进一次中断AIR_FREQ值+1，0.1s为一个周期，这样就可以测出方波的频率，再对照上述公式就可以算出气体流量 8.移动配载平台 移动配载平台的本质就是一个步进电机，通过步进电机带动丝杆转动来完成平台的移动，这是一个机械原理，不做过多解释 而步进电机的详细控制方法和上面的动力电机相同，不过多赘述。 9.电流传感器 电流传感器采用了TI家的INA226芯片，利用的是“加压求流”的原理，将一个100Ω的电阻串联到电源电路里，然后利用INA226的模数转换测出这个电阻两端的电压，进而就可以得到电源电路的电流。原理图如下 STM32只需要通过I2C通信与INA226连接，接收INA226传入的电流数据即可。 10.WIFI通信 WIFI通信利用的是ESP8266模块，ESP8266操作十分简便，几个AT指令便可以完成设置 STM32与ESP8266模块之间的通信利用TTL电平的UART串口通信即可。 下面列一下几个重要的AT指令： 1234567891011121.AT+RST #功能：重启模块2.AT+CWMODE=&lt;mode&gt; #功能：mode=1 :Station模式（接收模式）mode=2：AP模式（发送模式）mode=3：AP+Station模式3.AT+CWLIF #功能：查看已接入设备的 IP4.AT+CIFSR #功能：查看本模块的 IP 地址5.AT+CWJAP=&lt;ssid&gt;,&lt;pwd&gt; #功能：加入当前无线网络 '''说明： &lt;ssid&gt;:字符串参数，接入点名称&lt;pwd&gt;:字符串参数，密码，最长64字节ASCII响应：正确： OK错误： ERROR ''' ## 电路板设计 ### 原理图 ### PCB图 ### 电路板3D效果图 期待比赛取得好成绩！！ Max_ Speed为位置模式保存的目标转速，通过设置这个参数，可以更精确的控制需要的转速，也不用担心出现超过所设定的速度↩︎","link":"/2020/02/06/%E6%B0%94%E6%B3%A1%E8%88%B9%E7%94%B5%E8%B7%AF%E6%9D%BF%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%89%80%E6%8E%A5%E5%A4%96%E8%AE%BE%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86/"},{"title":"CORE学习：AMBA3--APB总线协议及简单例子","text":"AMBA3—APB总线 APB总线是AMBA里面最简单的一个总线接口了，它是一个非流水线结构，且控制逻辑简单，这也就决定了它是利用于低带宽的外围总线设备上，例如UART、IIC、定时器等等。注意，APB还有一个特点就是，APB的主机只有一个，那就是APB总线桥，不可能有其他主机，也不可能有多个主机。 ¶APB状态机 APB总线接口的状态转换图如图所示(ARM IHI 0024B - Page3-2): 可见，当总线复位后，APB进入IDLE状态，然后根据控制端口的输入切换状态，输出的数据和状态以及输入数据有关，因此是一个典型的Mealy型状态机，对它的详细解释如下： IDLE：APB 的默认状态，也就是没有传输时候的状态； SETUP：在IDLE状态下，将信号PSELx拉高(x是从设备选择信号)，进入SETUP状态，收到PENABLE信号进入下一状态； ACCESS：传输状态，根据PWRITE、PADDR、PWDATA/PRDATA写入/读取寄存器。完成后将PREADY拉高，PSELx未选中这个APB从机的话退回IDLE，选中但不传输数据(PENABLE拉低)的话退回SETUO；未完成的话PREADY拉低，并在下一个上升沿继续进入ACCESS传输数据； 整个状态很简单，三言两语就可以描述清楚了，那我们再回来看看APB接口是由哪些输入输出信号组成的： 12345678910//apb_interface input pclk, //时钟 input [AW-1:0] paddr, //地址 input pwrite, //读/写控制信号 input psel, //选择信号，类似于片选信号 input penable, //使能信号 input [DW-1:0] pwdata, //写(输入)数据 output reg [DW-1:0] prdata, //读(输出)数据 output reg pready, //传输完成标志，low未完成，high完成 output reg pslverr //错误标志，high出现错误 ¶传输时序 根据这些信号的不同组合，又可以分为带等待信号的数据输入/输出以及不带等待信号的输入/输出，接下来根据ARM的官方手册ARM IHI 0024B对这四种情况进行描(fan)述(yi)： ¶不带等待信号的数据写入时序 T1上升沿：拉高PSEL，选中这个APB从机，并且拉高PWRITE，表示接下来要写入数据给从机，并且将数据地址放在PADDR，数据放在PWDATA，从IDLE进入SETUP T2上升沿：PENABLE拉高，从SETUP进入ACCESS，进行一次数据传输 T3上升沿：PREADY被从机拉高，说明传输完成，PSEL和PENABLE可以拉低 ¶带等待信号的写入时序 T1上升沿：拉高PSEL，选中这个APB从机，并且拉高PWRITE，表示接下来要写入数据给从机，并且将数据地址放在PADDR，数据放在PWDATA，从IDLE进入SETUP T2上升沿：PENABLE拉高，从SETUP进入ACCESS，进行一次数据传输 T3上升沿：PREADY为低，说明数据还未写完/过程未处理完，需要等待一个时钟周期，再次进入ACCESS T4上升沿：PREADY还是低，再次进入ACCESS T5上升沿：PREADY被拉高，从机完成接受数据，PSEL和PENABLE拉低 ¶读取时序 读取时序的过程与写入时序基本一致，只不过读取时是将PWRITE拉低，而写入是将它拉低，这里不再详细分析时序图，有兴趣可以看官方文档，把图放在这里： ¶动手写一个APB外设 APB外设的逻辑状态和时序已经清楚了，接下来就自己动手写一个APB从机试试吧😍 ¶简单的APB从机 先确定好从机需要访问到的寄存器，在这里我定义四个寄存器来模拟： 12345reg [31:0] readonly32; //0x10000000，只可读reg [15:0] readonly16; //0x10000004，只可读reg [31:0] readwrite32; //0x10000008，可读可写reg [15:0] readwrite16; //0x1000000C，可读可写 实际上这四个寄存器可以通过改改名字和例化其他模块来实现APB外设的所有功能，比如将readwrite16中的16个位分别设置成UART输出模块的波特率控制位、传输帧设置位、中断使能位等等，readwrite32设置为UART输出信息的缓冲寄存器，这样可以实现一个简单的APB-UART外设 当然，这里我只想模拟下读写寄存器，就不需要例化其他模块了，完整的代码贴在下面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106`timescale 1ns/100psmodule apb_slave_test #( parameter AW = 32,//地址总线宽度 parameter DW = 32 //数据总线宽度 ) ( //system input reset_n, //apb_interface input pclk, //时钟 input [AW-1:0] paddr, //地址 input pwrite, //读/写控制信号 input psel, //选择信号 input penable, //使能信号 input [DW-1:0] pwdata, //写(输入)数据 output reg [DW-1:0] prdata, //读(输出)数据 output reg pready, //传输完成标志，low未完成，high完成 output reg pslverr //错误标志，high出现错误 );//apb状态机parameter IDLE = 2'b00;parameter SETUP = 2'b01;parameter ACCESS = 2'b10;reg [1:0] state_now = 2'b00;reg [1:0] state_next = 2'b00;//映射到总线上的寄存器reg [31:0] readonly32; //0x10000000，只可读reg [15:0] readonly16; //0x10000004，只可读reg [31:0] readwrite32; //0x10000008，可读可写reg [15:0] readwrite16; //0x1000000C，可读可写always @(posedge pclk or negedge reset_n) begin: init_and_change_state if (!reset_n) begin pready &lt;= 1'b0; pslverr &lt;= 1'b0; prdata &lt;= 32'h0; readwrite32 &lt;= 32'h0; readwrite16 &lt;= 16'h0; readonly32 &lt;= 32'h12345678; readonly16 &lt;= 16'habcd; state_now &lt;= IDLE; end else begin state_now &lt;= state_next; endend//! fsm_extractalways @(posedge pclk) begin :main_fsm_of_apb case (state_now) IDLE: begin //IDLE状态 case (psel) 1'b1: state_next &lt;= SETUP; //选择本apb外设，进入setup状态 1'b0: state_next &lt;= IDLE; default: state_next &lt;= IDLE; endcase end SETUP: begin//SETUP状态 case (psel) 1'b1: begin case (penable) 1'b1: state_next &lt;= ACCESS;//选中且enable信号拉高，进入ACCESS模式传输数据 1'b0: state_next &lt;= SETUP; default: state_next &lt;= SETUP; endcase end 1'b0: state_next &lt;= IDLE; //未被选中，回到IDLE default: state_next &lt;= IDLE; endcase pready &lt;= 1'b0; end ACCESS: begin //ACCESS状态，根据寄存器地址读写 prdata &lt;= 32'h0; pslverr &lt;= 1'b0; if (pwrite) begin //wirte信号拉高，写入模式 case (paddr) 32'h10000008: begin readwrite32 &lt;= pwdata; pready &lt;= 1'b1; end//数据传输完成 32'h1000000C: begin readwrite16 &lt;= pwdata[15:0]; pready &lt;= 1'b1; end//数据传输完成 default: pslverr &lt;= 1'b1; endcase end else if(!pwrite) begin //write信号拉低，读取模式 case (paddr) 32'h10000000: begin prdata &lt;= readonly32; pready &lt;= 1'b1; end//数据传输完成 32'h10000004: begin prdata &lt;= readonly16; pready &lt;= 1'b1; end//数据传输完成 32'h10000008: begin prdata &lt;= readwrite32; pready &lt;= 1'b1; end//数据传输完成 32'h1000000C: begin prdata &lt;= readwrite16; pready &lt;= 1'b1; end//数据传输完成 default: pslverr &lt;= 1'b1; endcase end if (pready) begin case (psel) 1'b1: state_next &lt;= SETUP; //不需要传输数据，回到SETUP 1'b0: state_next &lt;= IDLE; //未被选中，回到IDLE default: state_next &lt;= IDLE; endcase end else state_next &lt;= ACCESS; //需要继续传输数据，则回到ACCESS end default: state_next &lt;= IDLE; endcaseendendmodule ¶仿真测试一下 利用Vivado跑个行为仿真看看： 一点点来分析： 0ns～15ns：reset_n信号置0以后拉高，初始化APB从机 15ns：拉高了psel，模拟选中这个APB从机，即将进入SETUP状态 35ns：拉高了penable，即将进入ACCESS状态，但我并没有给出paddr以及pwrite，因此输出全0 55ns：pwrite拉高，paddr设为0x10000008，pwdata设为0x1234ffff，表明我即将向地址为0x10000008的寄存器写入0x1234ffff，这个地址的寄存器是readwrite32，可以看到这个时候它的值还是全0 57.5ns：可以看到readwrite32寄存器的值已经变成0x1234ffff，且pready已经置1(其实图中pready早就置1了而且没变过，这个图有bug，后来代码改了) 85ns：pwrite拉低，paddr设为0x10000000，表明我要读取地址为0x10000000的寄存器readonly32的数据 87.5ns：prdata输出0x12345678，这和我们设置的readonly32寄存器初始值相同 145ns：pwrite拉高，paddr设为0x1000000C，pwdata设为0x1234abcd，表明我即将向地址为0x1000000C的16位寄存器写入0x1234ffff，这个地址的寄存器是readwrite16，可以看到这个时候它的值还是全0 147.5ns：readwrite16寄存器的值已经变成0xabcd，成功地写入低16位到寄存器 185ns：尝试读取未定义的寄存器，地址为0x10000010 187.5ns：pslverr被置1，出现错误，功能正常 205ns：尝试读取地址为0x10000004的只读寄存器readonly16 207.5ns：pslverr重新置0，读取到寄存器的值0x0000abcd，功能正常 所以这个简单的APB外设功能应该没问题，有空把它挂到软核/硬核上看看情况☺️","link":"/2021/08/24/CORE%E5%AD%A6%E4%B9%A0%EF%BC%9AAMBA3--APB%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/"},{"title":"AMBA3—AHB总线(一)","text":"AMBA3—AHB总线(一) 作为AMBA的中流砥柱之一，AHB被用于高性能、高时钟频率的系统结构中，它多被用在ARM核与片内高速sram、flash、DMA和总线桥的连接。它和上次学到的APB的最大区别在于功能更加丰富，可以进行流水线操作，并且性能更强。 ¶AHB的特性 Burst传输 Split事务处理 单周期Master移交 单一时钟沿操作 无三态 更宽的总线配置（64/128） 流水线操作 可支持多个总线主设备 对于Split事务处理、多个Master的特性，这一篇就不写了，只讲讲最基础的数据传输以及流水线操作。更多细节可以查看AMBA5手册（ARM IHI 0033B.b ），本文中大量图片也来源于官方手册。 AHB总线主要由四部分构成： AHB主机(Master)：这和APB不同，APB的主机是且仅是APB桥，而AHB的主机可以是任何设备，包括DMA、CPU等等。同时，AHB的主机也可以向从机输出hredy信号，用来控制数据读写是否完成。，任何时候只能有一个主机处于有效状态并能使用总线。 AHB从机(Slave)：和APB从机类似，但AHB的从机不仅会输出hreadyout信号(类似于APB的pready)，而且会输出状态信息hresp，标志当且这一轮传输的状态。 AHB仲裁器(Arbiter)：集成在AHB总线桥中，用来分配主机和从机，它的目的是确保每次只有一个主机能够发起数据传输。 AHB译码器(Decoder)：根据AHB主机发出的读数据地址选择正确的从机hrdata信号线，进行信号读取。 ¶AHB的接口 不同于APB只有APB-Slave和APB-Bridge两种接口，AHB有 AHB-Master、AHB-Slave、AHB-Arbiter、AHB-Decoder四种接口，每种接口都有其不同的信号定义，因此较为复杂，但如果有APB的基础的话可以对比着看，会有更深刻的体会。下面根据手册的顺序依次简单介绍下前两种接口： ¶AHB-Master AHB-Master接口输入输出信号如下图： 和APB一样，AHB-Master也包含读hrdata/写hwdata信号、地址haddr信号、读/写控制信号hwrite以及hready和时钟和复位信号，这些信号的功能和APB总线同名信号的功能是一致的，但AHB又多了几组信号： hsize[2:0]：Master到Slave的信号，表示传输的大小，分别对应8bits(byte)、16bits(halfword),32bits(word),64bits, 128bits,256bits, 512bits,1024bits。 hburst[2:0]：Master到Slave的信号，表示Burst传输类型，具体下面讲。 hport：其实在新版本的APB总线里也有这个，是用来进行保护控制的，一般用不上。 htrans：Master到Slave的信号，表示传输类型，分别为IDLE、BUSY、SEQ和NONSEQ，后面详细说明。 hresp[2:0]：Slave到Master的信号，是从机接收情况的响应信号，分别有：OKAY、ERROR、RETRY和SPLIT四种响应，后面讲解。 hmastlock：Master到Arbiter的信号，表示主机是否正在执行一个锁定顺序的传输。 ¶AHB-Slave AHB-Slave接口输入输出信号如下图： 和Master基本没什么不同，无非就是输入输出方向换了个边( ¶传输过程 如果只看信号的简单传输，那么AHB的过程几乎与APB无异(后面会有时序图)，那么AHB的特点究竟体现在哪里呢？体现在多Master、多SLave之间的分配、调度和数据传输上，以及相对于APB特有的突发(Burst)传输。 ¶多主多从的总线桥系统 AHB-Busmatrix","link":"/2021/08/28/AMBA3%E2%80%94AHB%E6%80%BB%E7%BA%BF/"},{"title":"跨时钟域的典型：异步FIFO的设计","text":"跨时钟域的典型范例——异步FIFO “时钟域(clock domain)”可以说是数字集成电路中一个非常重要的内容了，那么，何谓“跨时钟域”？ 很好理解，在时序逻辑电路中，所有触发器、寄存器的运行都是由时钟激励而运行下去的。而一个大型的数字系统中不可能只有一种时钟： 例如Cortex-M3软核常常运行在50～100MHz、而UART串行口波特率要在921600以上的话，输入时钟频率最好高于200MHz、FPGA上的DDR3一般要求200MHz的时钟输入，不同PLL/MMCM输出的同频率时钟它们的相位也有可能不同…… 这么多不同时钟激励的系统要组合在一起并能进行数据交互，那么势必会遇到“跨时钟域”的问题，解决这个问题的一大方法之一就是利用异步FIFO进行数据交互 ¶什么是FIFO FIFO(First In First Out)，顾名思义，即先输入先输出的一种模块，FIFO一般分为同步FIFO和异步FIFO两种，同步FIFO即输入和输出在同一个时钟域中，异步FIFO即输入输出不处于同一个时钟域。 FIFO的存储模块可以看成一个二维寄存器(当然也可以通过生成ram代替)，因此有些概念需要掌握，即： FIFO宽度：指FIFO中一个空间容纳的数据比特数，即一个数据单位的大小，例如你要输入FIFO的是16位的数据，那么FIFO的宽度即为16bit FIFO深度：指FIFO中能容纳多少个数据单元，在异步FIFO中这个值往往是可以被计算出来的，例如： 在一个FIFO中，写时钟为100MHz，读时钟为50MHz，突发长度(一个时间段内需要读写的数据量)为120，那么写一个数据需要1/100MHz=10ns，读一个数据需要1/50MHz=20ns，写完一个突发长度耗时120*10=1200ns，而在写入的这段时间中只能读出1200ns/20ns=60个数据，那么在这一次突发传输中还有120-60=60个数据没有被读走，因此这个情况下FIFO的最小深度为60 ¶到底如何解决跨时钟域的问题 有的同志可能会立刻回答：用FIFO！那好，FIFO为什么能解决跨时钟域的问题呢？异步FIFO自己又是如何解决输入输出时钟不同域的问题呢？ 还是得从跨时钟域的深层次原因来看这个问题： ¶单bit跨时钟域 当以时钟域CLK-A为激励源的寄存器输出信号给时钟域为CLK-B的寄存器时，会出现什么情况？ 用verilog描述为： 12345678reg Q1,Q2;always@(posedge clk_a) begin Q1 &lt;= data;endalways@(posedge clk_b) begin Q2 &lt;= Q1;end 显然，Q1上的数据跨过了两个时钟域，那么如果当经过clk-a时输出的Q1不稳定时，clk-b端的DFF采样到的Q1数据将会是不可预测的，因为这两个时钟并非同源，所以可能无法满足第二个DFF的建立和保持时间，会让第二个DFF处于亚稳态。 那么如何解决这个问题呢？这个问题实际上无法解决，但我们可以让它(指不满足另一个DFF的setup和hold time，处于亚稳态)发生的概率几乎为零，有没有方法呢？有！“打两拍”处理即可 “打两拍”指让数据经过两个后级寄存器（两级DFF同步），具体为什么这样做就能有想降低出错概率，可以参考这篇文章：知乎-跨时钟域同步，为什么两级寄存器结构能够降低亚稳态？具体的电路是这样的： 用verilog描述为： 123456789reg Q1,Q2,Q3;always@(posedge clk_a) begin Q1 &lt;= data;endalways@(posedge clk_b) begin Q2 &lt;= Q1; Q3 &lt;= Q2;end 这样，第三个DFF处于亚稳态的概率大幅降低了，然而这是单个bit跨时钟域的情况，如果是多个bit呢？ ¶多bit跨时钟域 在异步FIFO中，不论是写入数据还是取出数据，都是对同一个Memory操作的，两者彼此独立，不会产生跨时钟域的问题，那么异步FIFO中跨时钟域的地方在哪里呢？在FIFO状态的判断上 应该了解到，FIFO是有几个状态判断标志的，例如：全空、全满、即将空和即将满等等状态，这些状态是根据写入和读取指针决定的，当写入指针等于读取指针的时候，FIFO为全空；当写入指针超过读取指针一圈(指写到FIFO底部后又重新从头开始写，再一次与读取指针相遇)的时候，FIFO为全满。那么显然，我们要获取FIFO的状态就得对读和写指针进行判断了，但是这两个指针分别是在不同时钟域内的，所以这时候便产生了多bit(正经fifo指针不可能只有1bit)跨时钟域的问题。 那么如何解决这个问题呢？打拍还能解决吗？我们来分析一下： 假如现在的写入指针wr-ptr = 4’b0111，读取指针rd-ptr = 4’b0011，即将在写入和读出的下一个上升沿判断指针，而写入时钟频率高于读取时钟频率，那么判断的时候可能会出现的情况为： 最好的情况：刚好写入和读取的时钟上升沿在同一时刻了，并且数据都满足了建立和保持时间后开始进行指针之间的比较，完全没有问题，比较的结果也是正确的。 出了点状况：读取指针的时钟在这一时刻翻转了，有了一个上升沿，这个时候读取的数据还没有准备好(DFF处于亚稳态)，rd-ptr = 4’b0zzz(后三bit无法确定，因为不稳定)，这下完了没法比较了。 又出了点状况：写入指针也恰好没法满足时序条件，而且写入指针的四位BCD码都即将进行翻转(0111-&gt;1000)，这下彻底完蛋了，写入和读取指针在这个状态下完全是不可测的 显然，出现第一种情况的概率小到可以忽略(😅)，那么这么严重的问题怎么解决呢？一个个看： 解决第2种情况的方法只需要我们进一步思考就行了，既然是读取指针没法满足写入指针的DFF输出数据的建立和保持条件，那么我再加一个DFF把读取指针同步到写入时钟域(或者把写入指针同步到读取时钟域)不就行了？没错，但是这样的话依旧无法解决第三个问题，怎么办？ 这个问题再进一步思考，其实是BCD码自身的缺陷问题，从0111自增一次变成1000的时候，四个位都变化了，这就导致有16种可能，那么有没有一种编码方式能让每次自增只变化一位码的呢？还真有，格雷码。 格雷码每自增一次，只会翻转一个bit，具体可以自己查一下，这样的话，如果从格雷码0111(0101BCD)跳转到下一状态0101(0110BCD)的时候，只有一位改变了，不论你建立和保持时间是否满足，其余三位都是不会变的，也就是说即使处于亚稳态，这个时候另一个时钟域读取到的数据也只可能是0111或者0101，况且我们还有对单bit跨时钟的解决办法—打两拍，因此这对我之后的比较几乎没有影响(关于利用格雷码解决异步FIFO的问题的详细解释，这个回答知乎-异步fifo格雷码同步问题讲解的非常清楚) 那么这个问题就解决了，可以开始着手设计FIFO了。 ¶异步FIFO的设计 为了遵循模块化和参数化的设计标准，同时方便以后直接生成BRAM实现FIFO，我将异步FIFO拆分成控制端和数据端，控制端负责接收写入读取信号，产生写入读取指针，并转换成格雷码判断FIFO状态；数据端负责接受写入读取指针和写入读取信号以及写入的数据，输出读取的数据。把上面的过程分析清楚了，写出整个设计毫无困难： ¶异步FIFO控制模块 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101module fifo_ctrl #( parameter Addr_Width = 5) ( input reset_n, input wr_clk, input wr_ena, input rd_clk, input rd_ena, output empty, output full, output [Addr_Width:0] wr_addr_ptr,//写地址指针，比地址位多1位是为了检测到回环 output [Addr_Width:0] rd_addr_ptr); reg wr_rstn; reg rd_rstn; reg [Addr_Width:0] wr_addr_count; reg [Addr_Width:0] rd_addr_count; wire [Addr_Width:0] wr_addr_gray; //转换成格雷码 reg [Addr_Width:0] wr_addr_gray_reg1; reg [Addr_Width:0] wr_addr_gray_reg2; wire [Addr_Width:0] rd_addr_gray; reg [Addr_Width:0] rd_addr_gray_reg1; reg [Addr_Width:0] rd_addr_gray_reg2; /*写入指针控制*/ //异步复位，同步释放，相当于把resetn打一拍避免亚稳态 always @(posedge wr_clk ) begin if (!reset_n) wr_rstn &lt;= 1'b0; else wr_rstn &lt;= 1'b1; end //写入指针变化，并记录写入地址 always @(posedge wr_clk or negedge wr_rstn) begin if (!wr_rstn) begin wr_addr_count &lt;= 0; wr_addr_gray_reg1 &lt;= 0; wr_addr_gray_reg2 &lt;= 0; end else if (wr_ena &amp; ~full) begin wr_addr_count = wr_addr_count + 1'b1; end else wr_addr_count = wr_addr_count; end assign wr_addr_ptr = wr_addr_count - rd_addr_count;/*读取指针控制*/ //异步复位，同步释放，相当于把resetn打一拍避免亚稳态 always @(posedge rd_clk ) begin if (!reset_n) rd_rstn &lt;= 1'b0; else rd_rstn &lt;= 1'b1; end //读取指针变化，并记录读取地址 always @(posedge rd_clk or negedge rd_rstn) begin if (!rd_rstn) begin rd_addr_count &lt;= 0; rd_addr_gray_reg1 &lt;= 0; rd_addr_gray_reg2 &lt;= 0; end else if (rd_ena &amp; ~empty) begin rd_addr_count = rd_addr_count + 1'b1; end else if (rd_addr_count &gt;= 'd31) begin rd_addr_count = 0; end else rd_addr_count = rd_addr_count; end assign rd_addr_ptr = rd_addr_count;/*转换成格雷码并同步到对应时钟域*/ //写入指针转为格雷码 assign wr_addr_gray = (wr_addr_count &gt;&gt; 1) ^ wr_addr_count; //读取指针转为格雷码 assign rd_addr_gray = (rd_addr_count &gt;&gt; 1) ^ rd_addr_count; //将写入指针的格雷码同步到读取时钟域，打两拍 always @(posedge rd_clk ) begin wr_addr_gray_reg1 &lt;= wr_addr_gray; wr_addr_gray_reg2 &lt;= wr_addr_gray_reg1; end //将读取指针的格雷码同步到写入时钟域，打两拍 always @(posedge wr_clk ) begin rd_addr_gray_reg1 &lt;= rd_addr_gray; rd_addr_gray_reg2 &lt;= rd_addr_gray_reg1; end/*判断FIFO空满状态*/ //如果读取和写入格雷码相同，则说明FIFO为空，rd_addr_gray和wr_addr_gray_reg2在同一时钟域下，不能用rd_addr_gray_reg2 assign empty = (rd_addr_gray == wr_addr_gray_reg2); //当写指针超过读指针一个轮回后即为写满，也即高两位相反，低位相同，FIFO满 assign full = (wr_addr_gray == {~rd_addr_gray_reg2[Addr_Width:Addr_Width-1],rd_addr_gray_reg2[Addr_Width-2:0]});endmodule ¶FIFO数据模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081module fifo_mem #( parameter Data_Width = 16, parameter Fifo_Depth = 32, parameter Addr_Width = 5) ( input reset_n, input wr_clk, input rd_clk, input rd_ena, input wr_ena, input full, input empty, input [Data_Width-1:0] wr_data, input [Addr_Width:0] wr_addr_ptr, input [Addr_Width:0] rd_addr_ptr, output [Data_Width-1:0] rd_data); reg [Data_Width-1:0] fifo_ram [Fifo_Depth-1:0]; //fifo存储空间 32*16bit reg wr_rstn; reg rd_rstn; reg [Data_Width-1:0] rd_data_reg;/*写入数据*/ //异步复位，同步释放，相当于把resetn打一拍避免亚稳态 always @(posedge wr_clk ) begin if (!reset_n) begin wr_rstn &lt;= 1'b0; end else wr_rstn &lt;= 1'b1; end //复位，将ram清空；未满时根据wr_ptr写入data genvar i; generate for (i = 0;i &lt; Fifo_Depth; i = i + 1 ) begin always @(posedge wr_clk or negedge wr_rstn) begin if (!wr_rstn) begin fifo_ram[i] &lt;= 0; end end end endgenerate always @(posedge wr_clk ) begin if (wr_ena &amp;&amp; !full) begin fifo_ram[wr_addr_ptr] &lt;= wr_data; end else fifo_ram[wr_addr_ptr] &lt;= fifo_ram[wr_addr_ptr]; end/*读取数据*/ //异步复位，同步释放，相当于把resetn打一拍避免亚稳态 always @(posedge rd_clk ) begin if (!reset_n) begin rd_data_reg &lt;= 0; rd_rstn &lt;= 1'b0; end else rd_rstn &lt;= 1'b1; end always @(posedge rd_clk or negedge rd_rstn) begin if (!rd_rstn) begin rd_data_reg &lt;= 0; end else if (rd_ena &amp;&amp; !empty) begin rd_data_reg &lt;= fifo_ram[rd_addr_ptr]; end else rd_data_reg &lt;= 0; end assign rd_data = rd_data_reg;endmodule ¶TOP_MODULE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960`timescale 1ns/100psmodule asyn_fifo_top #( parameter Data_Width = 16, parameter Fifo_Depth = 32, parameter Addr_Width = 5) ( input reset_n, input wr_clk, input wr_ena, input [Addr_Width-1:0] wr_data, input rd_clk, input rd_ena, output [Addr_Width-1:0] rd_data, output valid, output empty, output full); wire [Addr_Width:0] wr_addr_ptr; wire [Addr_Width:0] rd_addr_ptr; fifo_mem #( .Data_Width(Data_Width ), .Fifo_Depth(Fifo_Depth ), .Addr_Width (Addr_Width ) ) fifo_mem_dut ( .reset_n (reset_n ), .wr_clk (wr_clk ), .rd_clk (rd_clk ), .rd_ena (rd_ena ), .wr_ena (wr_ena ), .full (full ), .empty (empty ), .wr_data (wr_data ), .wr_addr_ptr (wr_addr_ptr ), .rd_addr_ptr (rd_addr_ptr ), .rd_data ( rd_data) ); fifo_ctrl #( .Addr_Width (Addr_Width ) ) fifo_ctrl_dut ( .reset_n (reset_n ), .wr_clk (wr_clk ), .wr_ena (wr_ena ), .rd_clk (rd_clk ), .rd_ena (rd_ena ), .empty (empty ), .full (full ), .wr_addr_ptr (wr_addr_ptr ), .rd_addr_ptr ( rd_addr_ptr) );endmodule 仿真测试结果：","link":"/2021/09/01/%E5%BC%82%E6%AD%A5FIFO%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"【2021集创赛】Cortex-M3语音识别声源定位系统","text":"团队介绍 参赛单位：武汉理工大学 队伍名称：木大木大 指导老师：钟毅，张家亮 参赛队员：甘云汉，陆国威，万禹壮 总决赛奖项：一等奖(ARM杯企业大奖) ## 写在前面 能获得企业大奖其实是出乎预料的，论复杂程度我自己认为可能也无法比的上其他学校的朋友们的(不过是因为今年没有线下交流，着实无法看到大家的作品)，但我觉得组委会能选择我们组作为企业大奖，可能也是想通过我们来拓宽大家的思路，而并不一定是我们的作品做的是多么完美。 学习了近几年ARM杯的作品，感觉大家都是在同一个领域做文章(当然去年那组BLDC的hxd例外)，那就是视觉和图像处理方面。这方面感觉大家做的都非常好了，无论是用现成的算法拆分成verilog中的矩阵运算，还是利用HLS这类高层次综合工具，我觉得如果继续做视觉方面的内容我们可能再怎么努力也无法达到他人积累多年经验的程度，所以我们选择换一个角度。 人类有五种感官，嗅觉和味觉目前来说无法做到辅助 (笑 ，还剩下听觉、视觉和触觉，视觉被我们直接否定了，那么触觉呢？目前高精度的传感器也不是我们能企及做到的了，这和生物医学电子有关，那么我们的眼前就只有一个选择了：听觉。 这也正是我们选择做这个系统的原因之一，还有一个原因是我们能感觉得到现在的消费电子都逐渐在向声学方面走，例如苹果的HomePod，华为的Sound X，还有小米最近刚推出的小米Sound，这些都是非常高端的走计算声学方向的家居产品，它们的受众非常广，而且在这两年疫情的影响下，更多的人会选择在线会议，那么一个优秀的声学处理装置就显得更为重要了。 设计简介 总体介绍 本作品是基于Coretex-M3 Design Start的语音识别和声源定位识别系统，包括Digilent NexysVideo开发板、自制麦克风矩阵模块、ESP8266无线互联模块、LCD屏幕、载体小车以及安卓端APP组成。 本系统在Xilinx Artix-7中搭建ARM Cortex-M3软核作为中央处理器，使用自制的MEMS硅片麦克风阵列作为声音信号采集器，利用Artix-7中自带的XADC将麦克风输出的模拟量信号转换为数字信号并通过AXI4-FULL传输给DDR3控制器，DDR3控制器根据用户的控制选择输入和输出，当开始语音识别后，将开启后1s内的数据从DDR3中直接利用Burst读入语音识别模块，该模块利用HLS综合，包括语音的MFCC特征提取、BP神经网络的执行等过程，将最终得出的语音识别结果保存在寄存器中并能使CPU通过AXI4-Lite读取；当开启声源定位后，数据利用AXI4-Stream直接搬移到算法电路模块，对四路麦克风同时进行流水线处理，经过信号的处理和变换后得到声源方位数据通过UART串口输出到ESP8266，ESP8266利用局域网将数据传至安卓APP。 有一点我们的体会可以分享给其他朋友们，如果我们在一段时间内只需要处理一段定长的数据，那么我们可以不利用DMA，而是仅仅利用AXI的Burst传输即可，例如采集1s的信号寸到DDR中一段连续区域以后，将这些的音频信号数据整个Burst到加速器中，这样可以充分发挥总线桥的作用，并节省一个DMA的资源，还可以减小数据搬移过来过去的时延。 硬件架构 总体架构 在本系统中，由于最终制作的语音识别加速器和声源定位加速器都使用AXI系列总线配置寄存器和读写数据，同时DDR3由AXI总线接口的MIG管理，因此为了方便实用和同一总线，使整个架构简洁，我们将除了ITCM和DTCM外的所有外设连接在由AHB转换之后的AXI总线桥上。 语音识别加速器 语音识别采用的方案是利用MFCC提取特征，之后利用BP神经网络拟合特征系数对应的神经网络隐含层参数。首先输入的语音数据从DDR经过Burst传输到信号处理模块中，经过预处理(去工频噪声、音量均衡)后提取MFCC，再利用BP网络将MFCC系数与训练过的语句一一对应输出对应的结果。语音识别的网络的权重参数采用的是MATLAB离线训练的方法，然后把训练的权重数据保存在coe文件中，利用HLS综合出IP。 流程图如下： 语音识别流程 声源定位加速器 声源定位加速器融合了TDOA(Time Difference of Arrival 到达时间差)和空域波束指向性加权的方法。 由四个全向性麦克风M1, M2, M3, M4组成的差分麦克风列，如图2.10所示。四麦克风等间隔的分布在直径为D的圆周上。 差分麦克风阵列的输出信号包括原点处的声压信号和原点处振速的两个正交分量，可以得到声源在原点处的声强，进而由声强的方向得到目标方位的估计值。需要指出的是，基于声强估计的声源定位方法通常只适用于单声源的情况。同时，对于全向麦克风而言(不同于“心”形指向麦克风)，并没有对特定角度的声源信号进行增强或削弱，这就使得在进行声源定位时往往受到其他方向的干扰。采用空域波束指向性加权的方法，可以只增强期望方向上的信号，削弱其他方向上的干扰信号，提高信干比，使得输出结果中特定方向上的信息能量增大。 作品外观和使用体验 作品成品外观如下： appearance.1 appearance.2 appearance.3 功能演示视频(双加速器协同处理效果在P2)： BiliBili-来个三连吧！ 没法线下交流海报的内容的话就转到线上吧 海报","link":"/2021/09/04/%E3%80%902021%E9%9B%86%E5%88%9B%E8%B5%9B%E3%80%91Cortex-M3%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%A3%B0%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F/"},{"title":"Renesas RE01B MCU Study Notes ：Overview","text":"这是一款基于Cortex-M0+的超低功耗MCU，但其实刚拿到文档的时候，它让我眼前一亮的并不是超低功耗这个关键词，而是它支持蓝牙5.0、具有2D加速的功能，也就是说这一块低功耗芯片片上就具有完整的无线通信协议栈，而不是像以前接触过的STMicro32那样。大胆预测一下，它应该是应用在长续航场景下的移动设备上，例如智能手环之类的。 ## Overview&amp;CPU 拿到它的第一件事是找它的Block Design Diagram，这样可以清晰的了解整体的结构： RE01B:Block Diagram CPU&amp;BUS&amp;DEBUG 可以看到，这颗MCU的Cortex-M0+是带有MPU的，因此在运行嵌入式OS的时候相较于以往用到的Cortex-M0多了一个存储器内存访问权限设置的功能。 除此之外，经查阅资料，Cortex-M0+还将原有的取指、译码、执行三级流水线压缩到了两级（取指+预解析、解析+执行），Cortex-M0+的可配置中断数和M0相同都是32个 由于目前手上能拿到的资料只有它官方的手册，其他有些手册是日文的…在手册中也并没有具体提到这款MCU使用了哪种BUS，只提到了调试时使用的CoreSight Access Ports用的是AHB-AP和APB-AP。 AP端口 如图，其中AHB-AP被直接连接在了CPU bus matrix上面，能够访问到CPU能访问的所有地址； APB-AP则连接到了特定的一块地址空间，叫OCD地址空间，并连接着OCD寄存器，目前不知道这是个什么。 SYSTEM Power-Saving Functions 这款芯片的精髓之一就在于使用了很多低功耗设计，包括以下部分： Clock division function Module stop function Power control modes Low power consumption modes Power supply modes 第一点Clock division function其实很常见，这个在STM32系列里也有，它的含义是具有一系列独立的分频器，可以按照需要给不同的片上外设分配不同的时钟频率，以节省不必要的能量消耗。 第二点Module stop function以前没见过，根据说明文档的描述，它可以独立地关闭每一个外设(原文：Supply of the clock signal can be stopped independently for each peripheral module)，不知道是不是只是瑞萨给自家外设模块的ip里写了和时钟解耦合的内容，即外设的使能口也能控制输入外设的时钟信号有无 第三点Power control modes分了几档速度，满速最高时钟频率64MHz、正常速度时钟频率32MHz这种。最低时钟频率是Low leakage current mode 低漏电流模式，时钟频率为32.768kHz 第四点Low power consumption modes应该是大家都有的功能，第五点是根据能量消耗芯片选择适合的电源域(Power Domain)。第四点第五点后面详细介绍几种模式的调度过程。 Operating Mode调度 OPE状态图 主要由三个Operating Mode组成，分别为Normal、Boost和Low leakage current（低漏电流模式，VBB） Normal operating mode是在MCU复位后进入的模式，高速模式下的运行频率在32MHz，低速模式的运行频率在2MHz，除此之外还有个Subosc-speed mode，频率和RTC时钟频率一致，为32.768KHz。 Low leakage current operating mode是当MCU运行在Subosc-speed mode且时钟频率不高于32.768KHz频率下时可以进入的一种模式，这种模式可以通过back bias voltage control(VBBC)降低漏电流，相同时钟频率下电量消耗比Normal中Subosc-speed mode更低。 Boost operating mode全功率运行模式，时钟频率最高，同样能耗也最高。它只能从Normal mode的高速模式下切换，并且power mode要在all power supply mode (ALLPWON)。 Power supply Mode调度 在提到Power supply mode之前，手册还提到了一个叫“电源域(Power domain)”的概念，可以类比于时钟域理解，即为了方便控制各个模块的供电，将它们的电源划分区域进行控制操作。 原文：Furthermore, in this chip, the power domain is divided into four to achieve low power consumption, and it can control power supply/shutoff of each power domain. 四个PowerDomain的分配 以及根据这四个电源域进行不同分配而产生的三种供电模式： All power supply mode(ALLPWON)：所有电源供应都开启，对应着上面提到的Boost operating mode Flash-excluded power supply mode(EXFPWON):顾名思义，包含FLash闪存的电源域(ISO3)被关闭，这个时候MCU的指令代码必须在SRAM中运行 Minimum power supply mode(MINPWON):这个模式下，ISO2和ISO3这两个电源域被关闭，只留下最基础的功能，同样由于FLASH没运行了，指令代码必须在SRAM上运行 后面详细学一下他这几个Power saving functions的实现方法，以及其他和功耗控制相关的外设。","link":"/2021/10/16/Renesas%20RE01B%20MCU%20Study%20Notes%20part1/"}],"tags":[{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"硬件","slug":"硬件","link":"/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"Verilog HDL","slug":"Verilog-HDL","link":"/tags/Verilog-HDL/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"2020节能减排","slug":"2020节能减排","link":"/tags/2020%E8%8A%82%E8%83%BD%E5%87%8F%E6%8E%92/"},{"name":"Bus&amp;Core","slug":"Bus-Core","link":"/tags/Bus-Core/"}],"categories":[{"name":"硬件","slug":"硬件","link":"/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"软件","slug":"软件","link":"/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"FPGA","slug":"硬件/FPGA","link":"/categories/%E7%A1%AC%E4%BB%B6/FPGA/"},{"name":"Python","slug":"软件/Python","link":"/categories/%E8%BD%AF%E4%BB%B6/Python/"},{"name":"Verilog HDL","slug":"硬件/FPGA/Verilog-HDL","link":"/categories/%E7%A1%AC%E4%BB%B6/FPGA/Verilog-HDL/"},{"name":"Bus&amp;Core","slug":"硬件/FPGA/Bus-Core","link":"/categories/%E7%A1%AC%E4%BB%B6/FPGA/Bus-Core/"},{"name":"FPGA","slug":"FPGA","link":"/categories/FPGA/"},{"name":"Bus&amp;Core","slug":"FPGA/Bus-Core","link":"/categories/FPGA/Bus-Core/"}]}